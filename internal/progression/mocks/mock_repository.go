// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	context "context"

	domain "github.com/osse101/BrandishBot_Go/internal/domain"
	mock "github.com/stretchr/testify/mock"

	repository "github.com/osse101/BrandishBot_Go/internal/repository"

	time "time"
)

// MockRepository is an autogenerated mock type for the Repository type
type MockRepository struct {
	mock.Mock
}

type MockRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockRepository) EXPECT() *MockRepository_Expecter {
	return &MockRepository_Expecter{mock: &_m.Mock}
}

// AddContribution provides a mock function with given fields: ctx, progressID, amount
func (_m *MockRepository) AddContribution(ctx context.Context, progressID int, amount int) error {
	ret := _m.Called(ctx, progressID, amount)

	if len(ret) == 0 {
		panic("no return value specified for AddContribution")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok {
		r0 = rf(ctx, progressID, amount)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_AddContribution_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddContribution'
type MockRepository_AddContribution_Call struct {
	*mock.Call
}

// AddContribution is a helper method to define mock.On call
//   - ctx context.Context
//   - progressID int
//   - amount int
func (_e *MockRepository_Expecter) AddContribution(ctx interface{}, progressID interface{}, amount interface{}) *MockRepository_AddContribution_Call {
	return &MockRepository_AddContribution_Call{Call: _e.mock.On("AddContribution", ctx, progressID, amount)}
}

func (_c *MockRepository_AddContribution_Call) Run(run func(ctx context.Context, progressID int, amount int)) *MockRepository_AddContribution_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_AddContribution_Call) Return(_a0 error) *MockRepository_AddContribution_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_AddContribution_Call) RunAndReturn(run func(context.Context, int, int) error) *MockRepository_AddContribution_Call {
	_c.Call.Return(run)
	return _c
}

// AddVotingOption provides a mock function with given fields: ctx, sessionID, nodeID, targetLevel
func (_m *MockRepository) AddVotingOption(ctx context.Context, sessionID int, nodeID int, targetLevel int) error {
	ret := _m.Called(ctx, sessionID, nodeID, targetLevel)

	if len(ret) == 0 {
		panic("no return value specified for AddVotingOption")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int) error); ok {
		r0 = rf(ctx, sessionID, nodeID, targetLevel)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_AddVotingOption_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AddVotingOption'
type MockRepository_AddVotingOption_Call struct {
	*mock.Call
}

// AddVotingOption is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID int
//   - nodeID int
//   - targetLevel int
func (_e *MockRepository_Expecter) AddVotingOption(ctx interface{}, sessionID interface{}, nodeID interface{}, targetLevel interface{}) *MockRepository_AddVotingOption_Call {
	return &MockRepository_AddVotingOption_Call{Call: _e.mock.On("AddVotingOption", ctx, sessionID, nodeID, targetLevel)}
}

func (_c *MockRepository_AddVotingOption_Call) Run(run func(ctx context.Context, sessionID int, nodeID int, targetLevel int)) *MockRepository_AddVotingOption_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int))
	})
	return _c
}

func (_c *MockRepository_AddVotingOption_Call) Return(_a0 error) *MockRepository_AddVotingOption_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_AddVotingOption_Call) RunAndReturn(run func(context.Context, int, int, int) error) *MockRepository_AddVotingOption_Call {
	_c.Call.Return(run)
	return _c
}

// BeginTx provides a mock function with given fields: ctx
func (_m *MockRepository) BeginTx(ctx context.Context) (repository.Tx, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for BeginTx")
	}

	var r0 repository.Tx
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (repository.Tx, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) repository.Tx); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(repository.Tx)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_BeginTx_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BeginTx'
type MockRepository_BeginTx_Call struct {
	*mock.Call
}

// BeginTx is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) BeginTx(ctx interface{}) *MockRepository_BeginTx_Call {
	return &MockRepository_BeginTx_Call{Call: _e.mock.On("BeginTx", ctx)}
}

func (_c *MockRepository_BeginTx_Call) Run(run func(ctx context.Context)) *MockRepository_BeginTx_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_BeginTx_Call) Return(_a0 repository.Tx, _a1 error) *MockRepository_BeginTx_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_BeginTx_Call) RunAndReturn(run func(context.Context) (repository.Tx, error)) *MockRepository_BeginTx_Call {
	_c.Call.Return(run)
	return _c
}

// CompleteUnlock provides a mock function with given fields: ctx, progressID, rolloverPoints
func (_m *MockRepository) CompleteUnlock(ctx context.Context, progressID int, rolloverPoints int) (int, error) {
	ret := _m.Called(ctx, progressID, rolloverPoints)

	if len(ret) == 0 {
		panic("no return value specified for CompleteUnlock")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) (int, error)); ok {
		return rf(ctx, progressID, rolloverPoints)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) int); ok {
		r0 = rf(ctx, progressID, rolloverPoints)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, progressID, rolloverPoints)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_CompleteUnlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CompleteUnlock'
type MockRepository_CompleteUnlock_Call struct {
	*mock.Call
}

// CompleteUnlock is a helper method to define mock.On call
//   - ctx context.Context
//   - progressID int
//   - rolloverPoints int
func (_e *MockRepository_Expecter) CompleteUnlock(ctx interface{}, progressID interface{}, rolloverPoints interface{}) *MockRepository_CompleteUnlock_Call {
	return &MockRepository_CompleteUnlock_Call{Call: _e.mock.On("CompleteUnlock", ctx, progressID, rolloverPoints)}
}

func (_c *MockRepository_CompleteUnlock_Call) Run(run func(ctx context.Context, progressID int, rolloverPoints int)) *MockRepository_CompleteUnlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_CompleteUnlock_Call) Return(_a0 int, _a1 error) *MockRepository_CompleteUnlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_CompleteUnlock_Call) RunAndReturn(run func(context.Context, int, int) (int, error)) *MockRepository_CompleteUnlock_Call {
	_c.Call.Return(run)
	return _c
}

// CreateUnlockProgress provides a mock function with given fields: ctx
func (_m *MockRepository) CreateUnlockProgress(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CreateUnlockProgress")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_CreateUnlockProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateUnlockProgress'
type MockRepository_CreateUnlockProgress_Call struct {
	*mock.Call
}

// CreateUnlockProgress is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) CreateUnlockProgress(ctx interface{}) *MockRepository_CreateUnlockProgress_Call {
	return &MockRepository_CreateUnlockProgress_Call{Call: _e.mock.On("CreateUnlockProgress", ctx)}
}

func (_c *MockRepository_CreateUnlockProgress_Call) Run(run func(ctx context.Context)) *MockRepository_CreateUnlockProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_CreateUnlockProgress_Call) Return(_a0 int, _a1 error) *MockRepository_CreateUnlockProgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_CreateUnlockProgress_Call) RunAndReturn(run func(context.Context) (int, error)) *MockRepository_CreateUnlockProgress_Call {
	_c.Call.Return(run)
	return _c
}

// CreateVotingSession provides a mock function with given fields: ctx
func (_m *MockRepository) CreateVotingSession(ctx context.Context) (int, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CreateVotingSession")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (int, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) int); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_CreateVotingSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateVotingSession'
type MockRepository_CreateVotingSession_Call struct {
	*mock.Call
}

// CreateVotingSession is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) CreateVotingSession(ctx interface{}) *MockRepository_CreateVotingSession_Call {
	return &MockRepository_CreateVotingSession_Call{Call: _e.mock.On("CreateVotingSession", ctx)}
}

func (_c *MockRepository_CreateVotingSession_Call) Run(run func(ctx context.Context)) *MockRepository_CreateVotingSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_CreateVotingSession_Call) Return(_a0 int, _a1 error) *MockRepository_CreateVotingSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_CreateVotingSession_Call) RunAndReturn(run func(context.Context) (int, error)) *MockRepository_CreateVotingSession_Call {
	_c.Call.Return(run)
	return _c
}

// EndVotingSession provides a mock function with given fields: ctx, sessionID, winningOptionID
func (_m *MockRepository) EndVotingSession(ctx context.Context, sessionID int, winningOptionID *int) error {
	ret := _m.Called(ctx, sessionID, winningOptionID)

	if len(ret) == 0 {
		panic("no return value specified for EndVotingSession")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, *int) error); ok {
		r0 = rf(ctx, sessionID, winningOptionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_EndVotingSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'EndVotingSession'
type MockRepository_EndVotingSession_Call struct {
	*mock.Call
}

// EndVotingSession is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID int
//   - winningOptionID *int
func (_e *MockRepository_Expecter) EndVotingSession(ctx interface{}, sessionID interface{}, winningOptionID interface{}) *MockRepository_EndVotingSession_Call {
	return &MockRepository_EndVotingSession_Call{Call: _e.mock.On("EndVotingSession", ctx, sessionID, winningOptionID)}
}

func (_c *MockRepository_EndVotingSession_Call) Run(run func(ctx context.Context, sessionID int, winningOptionID *int)) *MockRepository_EndVotingSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(*int))
	})
	return _c
}

func (_c *MockRepository_EndVotingSession_Call) Return(_a0 error) *MockRepository_EndVotingSession_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_EndVotingSession_Call) RunAndReturn(run func(context.Context, int, *int) error) *MockRepository_EndVotingSession_Call {
	_c.Call.Return(run)
	return _c
}

// FreezeVotingSession provides a mock function with given fields: ctx, sessionID
func (_m *MockRepository) FreezeVotingSession(ctx context.Context, sessionID int) error {
	ret := _m.Called(ctx, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for FreezeVotingSession")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, sessionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_FreezeVotingSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FreezeVotingSession'
type MockRepository_FreezeVotingSession_Call struct {
	*mock.Call
}

// FreezeVotingSession is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID int
func (_e *MockRepository_Expecter) FreezeVotingSession(ctx interface{}, sessionID interface{}) *MockRepository_FreezeVotingSession_Call {
	return &MockRepository_FreezeVotingSession_Call{Call: _e.mock.On("FreezeVotingSession", ctx, sessionID)}
}

func (_c *MockRepository_FreezeVotingSession_Call) Run(run func(ctx context.Context, sessionID int)) *MockRepository_FreezeVotingSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_FreezeVotingSession_Call) Return(_a0 error) *MockRepository_FreezeVotingSession_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_FreezeVotingSession_Call) RunAndReturn(run func(context.Context, int) error) *MockRepository_FreezeVotingSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveOrFrozenSession provides a mock function with given fields: ctx
func (_m *MockRepository) GetActiveOrFrozenSession(ctx context.Context) (*domain.ProgressionVotingSession, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveOrFrozenSession")
	}

	var r0 *domain.ProgressionVotingSession
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*domain.ProgressionVotingSession, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *domain.ProgressionVotingSession); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ProgressionVotingSession)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetActiveOrFrozenSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveOrFrozenSession'
type MockRepository_GetActiveOrFrozenSession_Call struct {
	*mock.Call
}

// GetActiveOrFrozenSession is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) GetActiveOrFrozenSession(ctx interface{}) *MockRepository_GetActiveOrFrozenSession_Call {
	return &MockRepository_GetActiveOrFrozenSession_Call{Call: _e.mock.On("GetActiveOrFrozenSession", ctx)}
}

func (_c *MockRepository_GetActiveOrFrozenSession_Call) Run(run func(ctx context.Context)) *MockRepository_GetActiveOrFrozenSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_GetActiveOrFrozenSession_Call) Return(_a0 *domain.ProgressionVotingSession, _a1 error) *MockRepository_GetActiveOrFrozenSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetActiveOrFrozenSession_Call) RunAndReturn(run func(context.Context) (*domain.ProgressionVotingSession, error)) *MockRepository_GetActiveOrFrozenSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveSession provides a mock function with given fields: ctx
func (_m *MockRepository) GetActiveSession(ctx context.Context) (*domain.ProgressionVotingSession, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveSession")
	}

	var r0 *domain.ProgressionVotingSession
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*domain.ProgressionVotingSession, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *domain.ProgressionVotingSession); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ProgressionVotingSession)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetActiveSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveSession'
type MockRepository_GetActiveSession_Call struct {
	*mock.Call
}

// GetActiveSession is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) GetActiveSession(ctx interface{}) *MockRepository_GetActiveSession_Call {
	return &MockRepository_GetActiveSession_Call{Call: _e.mock.On("GetActiveSession", ctx)}
}

func (_c *MockRepository_GetActiveSession_Call) Run(run func(ctx context.Context)) *MockRepository_GetActiveSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_GetActiveSession_Call) Return(_a0 *domain.ProgressionVotingSession, _a1 error) *MockRepository_GetActiveSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetActiveSession_Call) RunAndReturn(run func(context.Context) (*domain.ProgressionVotingSession, error)) *MockRepository_GetActiveSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetActiveUnlockProgress provides a mock function with given fields: ctx
func (_m *MockRepository) GetActiveUnlockProgress(ctx context.Context) (*domain.UnlockProgress, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetActiveUnlockProgress")
	}

	var r0 *domain.UnlockProgress
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*domain.UnlockProgress, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *domain.UnlockProgress); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.UnlockProgress)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetActiveUnlockProgress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetActiveUnlockProgress'
type MockRepository_GetActiveUnlockProgress_Call struct {
	*mock.Call
}

// GetActiveUnlockProgress is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) GetActiveUnlockProgress(ctx interface{}) *MockRepository_GetActiveUnlockProgress_Call {
	return &MockRepository_GetActiveUnlockProgress_Call{Call: _e.mock.On("GetActiveUnlockProgress", ctx)}
}

func (_c *MockRepository_GetActiveUnlockProgress_Call) Run(run func(ctx context.Context)) *MockRepository_GetActiveUnlockProgress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_GetActiveUnlockProgress_Call) Return(_a0 *domain.UnlockProgress, _a1 error) *MockRepository_GetActiveUnlockProgress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetActiveUnlockProgress_Call) RunAndReturn(run func(context.Context) (*domain.UnlockProgress, error)) *MockRepository_GetActiveUnlockProgress_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllNodes provides a mock function with given fields: ctx
func (_m *MockRepository) GetAllNodes(ctx context.Context) ([]*domain.ProgressionNode, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllNodes")
	}

	var r0 []*domain.ProgressionNode
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*domain.ProgressionNode, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*domain.ProgressionNode); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.ProgressionNode)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetAllNodes_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllNodes'
type MockRepository_GetAllNodes_Call struct {
	*mock.Call
}

// GetAllNodes is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) GetAllNodes(ctx interface{}) *MockRepository_GetAllNodes_Call {
	return &MockRepository_GetAllNodes_Call{Call: _e.mock.On("GetAllNodes", ctx)}
}

func (_c *MockRepository_GetAllNodes_Call) Run(run func(ctx context.Context)) *MockRepository_GetAllNodes_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_GetAllNodes_Call) Return(_a0 []*domain.ProgressionNode, _a1 error) *MockRepository_GetAllNodes_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetAllNodes_Call) RunAndReturn(run func(context.Context) ([]*domain.ProgressionNode, error)) *MockRepository_GetAllNodes_Call {
	_c.Call.Return(run)
	return _c
}

// GetAllUnlocks provides a mock function with given fields: ctx
func (_m *MockRepository) GetAllUnlocks(ctx context.Context) ([]*domain.ProgressionUnlock, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetAllUnlocks")
	}

	var r0 []*domain.ProgressionUnlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) ([]*domain.ProgressionUnlock, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) []*domain.ProgressionUnlock); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.ProgressionUnlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetAllUnlocks_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetAllUnlocks'
type MockRepository_GetAllUnlocks_Call struct {
	*mock.Call
}

// GetAllUnlocks is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) GetAllUnlocks(ctx interface{}) *MockRepository_GetAllUnlocks_Call {
	return &MockRepository_GetAllUnlocks_Call{Call: _e.mock.On("GetAllUnlocks", ctx)}
}

func (_c *MockRepository_GetAllUnlocks_Call) Run(run func(ctx context.Context)) *MockRepository_GetAllUnlocks_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_GetAllUnlocks_Call) Return(_a0 []*domain.ProgressionUnlock, _a1 error) *MockRepository_GetAllUnlocks_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetAllUnlocks_Call) RunAndReturn(run func(context.Context) ([]*domain.ProgressionUnlock, error)) *MockRepository_GetAllUnlocks_Call {
	_c.Call.Return(run)
	return _c
}

// GetContributionLeaderboard provides a mock function with given fields: ctx, limit
func (_m *MockRepository) GetContributionLeaderboard(ctx context.Context, limit int) ([]domain.ContributionLeaderboardEntry, error) {
	ret := _m.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for GetContributionLeaderboard")
	}

	var r0 []domain.ContributionLeaderboardEntry
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]domain.ContributionLeaderboardEntry, error)); ok {
		return rf(ctx, limit)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []domain.ContributionLeaderboardEntry); ok {
		r0 = rf(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.ContributionLeaderboardEntry)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetContributionLeaderboard_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetContributionLeaderboard'
type MockRepository_GetContributionLeaderboard_Call struct {
	*mock.Call
}

// GetContributionLeaderboard is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockRepository_Expecter) GetContributionLeaderboard(ctx interface{}, limit interface{}) *MockRepository_GetContributionLeaderboard_Call {
	return &MockRepository_GetContributionLeaderboard_Call{Call: _e.mock.On("GetContributionLeaderboard", ctx, limit)}
}

func (_c *MockRepository_GetContributionLeaderboard_Call) Run(run func(ctx context.Context, limit int)) *MockRepository_GetContributionLeaderboard_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetContributionLeaderboard_Call) Return(_a0 []domain.ContributionLeaderboardEntry, _a1 error) *MockRepository_GetContributionLeaderboard_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetContributionLeaderboard_Call) RunAndReturn(run func(context.Context, int) ([]domain.ContributionLeaderboardEntry, error)) *MockRepository_GetContributionLeaderboard_Call {
	_c.Call.Return(run)
	return _c
}

// GetDailyEngagementTotals provides a mock function with given fields: ctx, since
func (_m *MockRepository) GetDailyEngagementTotals(ctx context.Context, since time.Time) (map[time.Time]int, error) {
	ret := _m.Called(ctx, since)

	if len(ret) == 0 {
		panic("no return value specified for GetDailyEngagementTotals")
	}

	var r0 map[time.Time]int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) (map[time.Time]int, error)); ok {
		return rf(ctx, since)
	}
	if rf, ok := ret.Get(0).(func(context.Context, time.Time) map[time.Time]int); ok {
		r0 = rf(ctx, since)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[time.Time]int)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, time.Time) error); ok {
		r1 = rf(ctx, since)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetDailyEngagementTotals_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDailyEngagementTotals'
type MockRepository_GetDailyEngagementTotals_Call struct {
	*mock.Call
}

// GetDailyEngagementTotals is a helper method to define mock.On call
//   - ctx context.Context
//   - since time.Time
func (_e *MockRepository_Expecter) GetDailyEngagementTotals(ctx interface{}, since interface{}) *MockRepository_GetDailyEngagementTotals_Call {
	return &MockRepository_GetDailyEngagementTotals_Call{Call: _e.mock.On("GetDailyEngagementTotals", ctx, since)}
}

func (_c *MockRepository_GetDailyEngagementTotals_Call) Run(run func(ctx context.Context, since time.Time)) *MockRepository_GetDailyEngagementTotals_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(time.Time))
	})
	return _c
}

func (_c *MockRepository_GetDailyEngagementTotals_Call) Return(_a0 map[time.Time]int, _a1 error) *MockRepository_GetDailyEngagementTotals_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetDailyEngagementTotals_Call) RunAndReturn(run func(context.Context, time.Time) (map[time.Time]int, error)) *MockRepository_GetDailyEngagementTotals_Call {
	_c.Call.Return(run)
	return _c
}

// GetDependents provides a mock function with given fields: ctx, nodeID
func (_m *MockRepository) GetDependents(ctx context.Context, nodeID int) ([]*domain.ProgressionNode, error) {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for GetDependents")
	}

	var r0 []*domain.ProgressionNode
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*domain.ProgressionNode, error)); ok {
		return rf(ctx, nodeID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*domain.ProgressionNode); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.ProgressionNode)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, nodeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetDependents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetDependents'
type MockRepository_GetDependents_Call struct {
	*mock.Call
}

// GetDependents is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID int
func (_e *MockRepository_Expecter) GetDependents(ctx interface{}, nodeID interface{}) *MockRepository_GetDependents_Call {
	return &MockRepository_GetDependents_Call{Call: _e.mock.On("GetDependents", ctx, nodeID)}
}

func (_c *MockRepository_GetDependents_Call) Run(run func(ctx context.Context, nodeID int)) *MockRepository_GetDependents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetDependents_Call) Return(_a0 []*domain.ProgressionNode, _a1 error) *MockRepository_GetDependents_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetDependents_Call) RunAndReturn(run func(context.Context, int) ([]*domain.ProgressionNode, error)) *MockRepository_GetDependents_Call {
	_c.Call.Return(run)
	return _c
}

// GetEngagementScore provides a mock function with given fields: ctx, since
func (_m *MockRepository) GetEngagementScore(ctx context.Context, since *time.Time) (int, error) {
	ret := _m.Called(ctx, since)

	if len(ret) == 0 {
		panic("no return value specified for GetEngagementScore")
	}

	var r0 int
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *time.Time) (int, error)); ok {
		return rf(ctx, since)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *time.Time) int); ok {
		r0 = rf(ctx, since)
	} else {
		r0 = ret.Get(0).(int)
	}

	if rf, ok := ret.Get(1).(func(context.Context, *time.Time) error); ok {
		r1 = rf(ctx, since)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetEngagementScore_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEngagementScore'
type MockRepository_GetEngagementScore_Call struct {
	*mock.Call
}

// GetEngagementScore is a helper method to define mock.On call
//   - ctx context.Context
//   - since *time.Time
func (_e *MockRepository_Expecter) GetEngagementScore(ctx interface{}, since interface{}) *MockRepository_GetEngagementScore_Call {
	return &MockRepository_GetEngagementScore_Call{Call: _e.mock.On("GetEngagementScore", ctx, since)}
}

func (_c *MockRepository_GetEngagementScore_Call) Run(run func(ctx context.Context, since *time.Time)) *MockRepository_GetEngagementScore_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*time.Time))
	})
	return _c
}

func (_c *MockRepository_GetEngagementScore_Call) Return(_a0 int, _a1 error) *MockRepository_GetEngagementScore_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetEngagementScore_Call) RunAndReturn(run func(context.Context, *time.Time) (int, error)) *MockRepository_GetEngagementScore_Call {
	_c.Call.Return(run)
	return _c
}

// GetEngagementWeights provides a mock function with given fields: ctx
func (_m *MockRepository) GetEngagementWeights(ctx context.Context) (map[string]float64, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetEngagementWeights")
	}

	var r0 map[string]float64
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (map[string]float64, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) map[string]float64); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]float64)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetEngagementWeights_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetEngagementWeights'
type MockRepository_GetEngagementWeights_Call struct {
	*mock.Call
}

// GetEngagementWeights is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) GetEngagementWeights(ctx interface{}) *MockRepository_GetEngagementWeights_Call {
	return &MockRepository_GetEngagementWeights_Call{Call: _e.mock.On("GetEngagementWeights", ctx)}
}

func (_c *MockRepository_GetEngagementWeights_Call) Run(run func(ctx context.Context)) *MockRepository_GetEngagementWeights_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_GetEngagementWeights_Call) Return(_a0 map[string]float64, _a1 error) *MockRepository_GetEngagementWeights_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetEngagementWeights_Call) RunAndReturn(run func(context.Context) (map[string]float64, error)) *MockRepository_GetEngagementWeights_Call {
	_c.Call.Return(run)
	return _c
}

// GetMostRecentSession provides a mock function with given fields: ctx
func (_m *MockRepository) GetMostRecentSession(ctx context.Context) (*domain.ProgressionVotingSession, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetMostRecentSession")
	}

	var r0 *domain.ProgressionVotingSession
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*domain.ProgressionVotingSession, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *domain.ProgressionVotingSession); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ProgressionVotingSession)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetMostRecentSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMostRecentSession'
type MockRepository_GetMostRecentSession_Call struct {
	*mock.Call
}

// GetMostRecentSession is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockRepository_Expecter) GetMostRecentSession(ctx interface{}) *MockRepository_GetMostRecentSession_Call {
	return &MockRepository_GetMostRecentSession_Call{Call: _e.mock.On("GetMostRecentSession", ctx)}
}

func (_c *MockRepository_GetMostRecentSession_Call) Run(run func(ctx context.Context)) *MockRepository_GetMostRecentSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context))
	})
	return _c
}

func (_c *MockRepository_GetMostRecentSession_Call) Return(_a0 *domain.ProgressionVotingSession, _a1 error) *MockRepository_GetMostRecentSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetMostRecentSession_Call) RunAndReturn(run func(context.Context) (*domain.ProgressionVotingSession, error)) *MockRepository_GetMostRecentSession_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeByFeatureKey provides a mock function with given fields: ctx, featureKey
func (_m *MockRepository) GetNodeByFeatureKey(ctx context.Context, featureKey string) (*domain.ProgressionNode, int, error) {
	ret := _m.Called(ctx, featureKey)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeByFeatureKey")
	}

	var r0 *domain.ProgressionNode
	var r1 int
	var r2 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.ProgressionNode, int, error)); ok {
		return rf(ctx, featureKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.ProgressionNode); ok {
		r0 = rf(ctx, featureKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ProgressionNode)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) int); ok {
		r1 = rf(ctx, featureKey)
	} else {
		r1 = ret.Get(1).(int)
	}

	if rf, ok := ret.Get(2).(func(context.Context, string) error); ok {
		r2 = rf(ctx, featureKey)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// MockRepository_GetNodeByFeatureKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeByFeatureKey'
type MockRepository_GetNodeByFeatureKey_Call struct {
	*mock.Call
}

// GetNodeByFeatureKey is a helper method to define mock.On call
//   - ctx context.Context
//   - featureKey string
func (_e *MockRepository_Expecter) GetNodeByFeatureKey(ctx interface{}, featureKey interface{}) *MockRepository_GetNodeByFeatureKey_Call {
	return &MockRepository_GetNodeByFeatureKey_Call{Call: _e.mock.On("GetNodeByFeatureKey", ctx, featureKey)}
}

func (_c *MockRepository_GetNodeByFeatureKey_Call) Run(run func(ctx context.Context, featureKey string)) *MockRepository_GetNodeByFeatureKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetNodeByFeatureKey_Call) Return(_a0 *domain.ProgressionNode, _a1 int, _a2 error) *MockRepository_GetNodeByFeatureKey_Call {
	_c.Call.Return(_a0, _a1, _a2)
	return _c
}

func (_c *MockRepository_GetNodeByFeatureKey_Call) RunAndReturn(run func(context.Context, string) (*domain.ProgressionNode, int, error)) *MockRepository_GetNodeByFeatureKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeByID provides a mock function with given fields: ctx, id
func (_m *MockRepository) GetNodeByID(ctx context.Context, id int) (*domain.ProgressionNode, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeByID")
	}

	var r0 *domain.ProgressionNode
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*domain.ProgressionNode, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *domain.ProgressionNode); ok {
		r0 = rf(ctx, id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ProgressionNode)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetNodeByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeByID'
type MockRepository_GetNodeByID_Call struct {
	*mock.Call
}

// GetNodeByID is a helper method to define mock.On call
//   - ctx context.Context
//   - id int
func (_e *MockRepository_Expecter) GetNodeByID(ctx interface{}, id interface{}) *MockRepository_GetNodeByID_Call {
	return &MockRepository_GetNodeByID_Call{Call: _e.mock.On("GetNodeByID", ctx, id)}
}

func (_c *MockRepository_GetNodeByID_Call) Run(run func(ctx context.Context, id int)) *MockRepository_GetNodeByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetNodeByID_Call) Return(_a0 *domain.ProgressionNode, _a1 error) *MockRepository_GetNodeByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetNodeByID_Call) RunAndReturn(run func(context.Context, int) (*domain.ProgressionNode, error)) *MockRepository_GetNodeByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetNodeByKey provides a mock function with given fields: ctx, nodeKey
func (_m *MockRepository) GetNodeByKey(ctx context.Context, nodeKey string) (*domain.ProgressionNode, error) {
	ret := _m.Called(ctx, nodeKey)

	if len(ret) == 0 {
		panic("no return value specified for GetNodeByKey")
	}

	var r0 *domain.ProgressionNode
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.ProgressionNode, error)); ok {
		return rf(ctx, nodeKey)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.ProgressionNode); ok {
		r0 = rf(ctx, nodeKey)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ProgressionNode)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, nodeKey)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetNodeByKey_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNodeByKey'
type MockRepository_GetNodeByKey_Call struct {
	*mock.Call
}

// GetNodeByKey is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeKey string
func (_e *MockRepository_Expecter) GetNodeByKey(ctx interface{}, nodeKey interface{}) *MockRepository_GetNodeByKey_Call {
	return &MockRepository_GetNodeByKey_Call{Call: _e.mock.On("GetNodeByKey", ctx, nodeKey)}
}

func (_c *MockRepository_GetNodeByKey_Call) Run(run func(ctx context.Context, nodeKey string)) *MockRepository_GetNodeByKey_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetNodeByKey_Call) Return(_a0 *domain.ProgressionNode, _a1 error) *MockRepository_GetNodeByKey_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetNodeByKey_Call) RunAndReturn(run func(context.Context, string) (*domain.ProgressionNode, error)) *MockRepository_GetNodeByKey_Call {
	_c.Call.Return(run)
	return _c
}

// GetPrerequisites provides a mock function with given fields: ctx, nodeID
func (_m *MockRepository) GetPrerequisites(ctx context.Context, nodeID int) ([]*domain.ProgressionNode, error) {
	ret := _m.Called(ctx, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for GetPrerequisites")
	}

	var r0 []*domain.ProgressionNode
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]*domain.ProgressionNode, error)); ok {
		return rf(ctx, nodeID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []*domain.ProgressionNode); ok {
		r0 = rf(ctx, nodeID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.ProgressionNode)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, nodeID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetPrerequisites_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetPrerequisites'
type MockRepository_GetPrerequisites_Call struct {
	*mock.Call
}

// GetPrerequisites is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID int
func (_e *MockRepository_Expecter) GetPrerequisites(ctx interface{}, nodeID interface{}) *MockRepository_GetPrerequisites_Call {
	return &MockRepository_GetPrerequisites_Call{Call: _e.mock.On("GetPrerequisites", ctx, nodeID)}
}

func (_c *MockRepository_GetPrerequisites_Call) Run(run func(ctx context.Context, nodeID int)) *MockRepository_GetPrerequisites_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetPrerequisites_Call) Return(_a0 []*domain.ProgressionNode, _a1 error) *MockRepository_GetPrerequisites_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetPrerequisites_Call) RunAndReturn(run func(context.Context, int) ([]*domain.ProgressionNode, error)) *MockRepository_GetPrerequisites_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionByID provides a mock function with given fields: ctx, sessionID
func (_m *MockRepository) GetSessionByID(ctx context.Context, sessionID int) (*domain.ProgressionVotingSession, error) {
	ret := _m.Called(ctx, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionByID")
	}

	var r0 *domain.ProgressionVotingSession
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) (*domain.ProgressionVotingSession, error)); ok {
		return rf(ctx, sessionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) *domain.ProgressionVotingSession); ok {
		r0 = rf(ctx, sessionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ProgressionVotingSession)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, sessionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetSessionByID_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionByID'
type MockRepository_GetSessionByID_Call struct {
	*mock.Call
}

// GetSessionByID is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID int
func (_e *MockRepository_Expecter) GetSessionByID(ctx interface{}, sessionID interface{}) *MockRepository_GetSessionByID_Call {
	return &MockRepository_GetSessionByID_Call{Call: _e.mock.On("GetSessionByID", ctx, sessionID)}
}

func (_c *MockRepository_GetSessionByID_Call) Run(run func(ctx context.Context, sessionID int)) *MockRepository_GetSessionByID_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetSessionByID_Call) Return(_a0 *domain.ProgressionVotingSession, _a1 error) *MockRepository_GetSessionByID_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetSessionByID_Call) RunAndReturn(run func(context.Context, int) (*domain.ProgressionVotingSession, error)) *MockRepository_GetSessionByID_Call {
	_c.Call.Return(run)
	return _c
}

// GetSessionVoters provides a mock function with given fields: ctx, sessionID
func (_m *MockRepository) GetSessionVoters(ctx context.Context, sessionID int) ([]string, error) {
	ret := _m.Called(ctx, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for GetSessionVoters")
	}

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int) ([]string, error)); ok {
		return rf(ctx, sessionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int) []string); ok {
		r0 = rf(ctx, sessionID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = rf(ctx, sessionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetSessionVoters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSessionVoters'
type MockRepository_GetSessionVoters_Call struct {
	*mock.Call
}

// GetSessionVoters is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID int
func (_e *MockRepository_Expecter) GetSessionVoters(ctx interface{}, sessionID interface{}) *MockRepository_GetSessionVoters_Call {
	return &MockRepository_GetSessionVoters_Call{Call: _e.mock.On("GetSessionVoters", ctx, sessionID)}
}

func (_c *MockRepository_GetSessionVoters_Call) Run(run func(ctx context.Context, sessionID int)) *MockRepository_GetSessionVoters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_GetSessionVoters_Call) Return(_a0 []string, _a1 error) *MockRepository_GetSessionVoters_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetSessionVoters_Call) RunAndReturn(run func(context.Context, int) ([]string, error)) *MockRepository_GetSessionVoters_Call {
	_c.Call.Return(run)
	return _c
}

// GetSyncMetadata provides a mock function with given fields: ctx, configName
func (_m *MockRepository) GetSyncMetadata(ctx context.Context, configName string) (*domain.SyncMetadata, error) {
	ret := _m.Called(ctx, configName)

	if len(ret) == 0 {
		panic("no return value specified for GetSyncMetadata")
	}

	var r0 *domain.SyncMetadata
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.SyncMetadata, error)); ok {
		return rf(ctx, configName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.SyncMetadata); ok {
		r0 = rf(ctx, configName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.SyncMetadata)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, configName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetSyncMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetSyncMetadata'
type MockRepository_GetSyncMetadata_Call struct {
	*mock.Call
}

// GetSyncMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - configName string
func (_e *MockRepository_Expecter) GetSyncMetadata(ctx interface{}, configName interface{}) *MockRepository_GetSyncMetadata_Call {
	return &MockRepository_GetSyncMetadata_Call{Call: _e.mock.On("GetSyncMetadata", ctx, configName)}
}

func (_c *MockRepository_GetSyncMetadata_Call) Run(run func(ctx context.Context, configName string)) *MockRepository_GetSyncMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetSyncMetadata_Call) Return(_a0 *domain.SyncMetadata, _a1 error) *MockRepository_GetSyncMetadata_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetSyncMetadata_Call) RunAndReturn(run func(context.Context, string) (*domain.SyncMetadata, error)) *MockRepository_GetSyncMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// GetUnlock provides a mock function with given fields: ctx, nodeID, level
func (_m *MockRepository) GetUnlock(ctx context.Context, nodeID int, level int) (*domain.ProgressionUnlock, error) {
	ret := _m.Called(ctx, nodeID, level)

	if len(ret) == 0 {
		panic("no return value specified for GetUnlock")
	}

	var r0 *domain.ProgressionUnlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) (*domain.ProgressionUnlock, error)); ok {
		return rf(ctx, nodeID, level)
	}
	if rf, ok := ret.Get(0).(func(context.Context, int, int) *domain.ProgressionUnlock); ok {
		r0 = rf(ctx, nodeID, level)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ProgressionUnlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, int, int) error); ok {
		r1 = rf(ctx, nodeID, level)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetUnlock_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUnlock'
type MockRepository_GetUnlock_Call struct {
	*mock.Call
}

// GetUnlock is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID int
//   - level int
func (_e *MockRepository_Expecter) GetUnlock(ctx interface{}, nodeID interface{}, level interface{}) *MockRepository_GetUnlock_Call {
	return &MockRepository_GetUnlock_Call{Call: _e.mock.On("GetUnlock", ctx, nodeID, level)}
}

func (_c *MockRepository_GetUnlock_Call) Run(run func(ctx context.Context, nodeID int, level int)) *MockRepository_GetUnlock_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_GetUnlock_Call) Return(_a0 *domain.ProgressionUnlock, _a1 error) *MockRepository_GetUnlock_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetUnlock_Call) RunAndReturn(run func(context.Context, int, int) (*domain.ProgressionUnlock, error)) *MockRepository_GetUnlock_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserEngagement provides a mock function with given fields: ctx, userID
func (_m *MockRepository) GetUserEngagement(ctx context.Context, userID string) (*domain.ContributionBreakdown, error) {
	ret := _m.Called(ctx, userID)

	if len(ret) == 0 {
		panic("no return value specified for GetUserEngagement")
	}

	var r0 *domain.ContributionBreakdown
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*domain.ContributionBreakdown, error)); ok {
		return rf(ctx, userID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *domain.ContributionBreakdown); ok {
		r0 = rf(ctx, userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*domain.ContributionBreakdown)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetUserEngagement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserEngagement'
type MockRepository_GetUserEngagement_Call struct {
	*mock.Call
}

// GetUserEngagement is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
func (_e *MockRepository_Expecter) GetUserEngagement(ctx interface{}, userID interface{}) *MockRepository_GetUserEngagement_Call {
	return &MockRepository_GetUserEngagement_Call{Call: _e.mock.On("GetUserEngagement", ctx, userID)}
}

func (_c *MockRepository_GetUserEngagement_Call) Run(run func(ctx context.Context, userID string)) *MockRepository_GetUserEngagement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockRepository_GetUserEngagement_Call) Return(_a0 *domain.ContributionBreakdown, _a1 error) *MockRepository_GetUserEngagement_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetUserEngagement_Call) RunAndReturn(run func(context.Context, string) (*domain.ContributionBreakdown, error)) *MockRepository_GetUserEngagement_Call {
	_c.Call.Return(run)
	return _c
}

// GetUserProgressions provides a mock function with given fields: ctx, userID, progressionType
func (_m *MockRepository) GetUserProgressions(ctx context.Context, userID string, progressionType string) ([]*domain.UserProgression, error) {
	ret := _m.Called(ctx, userID, progressionType)

	if len(ret) == 0 {
		panic("no return value specified for GetUserProgressions")
	}

	var r0 []*domain.UserProgression
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]*domain.UserProgression, error)); ok {
		return rf(ctx, userID, progressionType)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []*domain.UserProgression); ok {
		r0 = rf(ctx, userID, progressionType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*domain.UserProgression)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userID, progressionType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_GetUserProgressions_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetUserProgressions'
type MockRepository_GetUserProgressions_Call struct {
	*mock.Call
}

// GetUserProgressions is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - progressionType string
func (_e *MockRepository_Expecter) GetUserProgressions(ctx interface{}, userID interface{}, progressionType interface{}) *MockRepository_GetUserProgressions_Call {
	return &MockRepository_GetUserProgressions_Call{Call: _e.mock.On("GetUserProgressions", ctx, userID, progressionType)}
}

func (_c *MockRepository_GetUserProgressions_Call) Run(run func(ctx context.Context, userID string, progressionType string)) *MockRepository_GetUserProgressions_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockRepository_GetUserProgressions_Call) Return(_a0 []*domain.UserProgression, _a1 error) *MockRepository_GetUserProgressions_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_GetUserProgressions_Call) RunAndReturn(run func(context.Context, string, string) ([]*domain.UserProgression, error)) *MockRepository_GetUserProgressions_Call {
	_c.Call.Return(run)
	return _c
}

// HasUserVotedInSession provides a mock function with given fields: ctx, userID, sessionID
func (_m *MockRepository) HasUserVotedInSession(ctx context.Context, userID string, sessionID int) (bool, error) {
	ret := _m.Called(ctx, userID, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for HasUserVotedInSession")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) (bool, error)); ok {
		return rf(ctx, userID, sessionID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) bool); ok {
		r0 = rf(ctx, userID, sessionID)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, userID, sessionID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_HasUserVotedInSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HasUserVotedInSession'
type MockRepository_HasUserVotedInSession_Call struct {
	*mock.Call
}

// HasUserVotedInSession is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - sessionID int
func (_e *MockRepository_Expecter) HasUserVotedInSession(ctx interface{}, userID interface{}, sessionID interface{}) *MockRepository_HasUserVotedInSession_Call {
	return &MockRepository_HasUserVotedInSession_Call{Call: _e.mock.On("HasUserVotedInSession", ctx, userID, sessionID)}
}

func (_c *MockRepository_HasUserVotedInSession_Call) Run(run func(ctx context.Context, userID string, sessionID int)) *MockRepository_HasUserVotedInSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_HasUserVotedInSession_Call) Return(_a0 bool, _a1 error) *MockRepository_HasUserVotedInSession_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_HasUserVotedInSession_Call) RunAndReturn(run func(context.Context, string, int) (bool, error)) *MockRepository_HasUserVotedInSession_Call {
	_c.Call.Return(run)
	return _c
}

// IncrementOptionVote provides a mock function with given fields: ctx, optionID
func (_m *MockRepository) IncrementOptionVote(ctx context.Context, optionID int) error {
	ret := _m.Called(ctx, optionID)

	if len(ret) == 0 {
		panic("no return value specified for IncrementOptionVote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, optionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_IncrementOptionVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IncrementOptionVote'
type MockRepository_IncrementOptionVote_Call struct {
	*mock.Call
}

// IncrementOptionVote is a helper method to define mock.On call
//   - ctx context.Context
//   - optionID int
func (_e *MockRepository_Expecter) IncrementOptionVote(ctx interface{}, optionID interface{}) *MockRepository_IncrementOptionVote_Call {
	return &MockRepository_IncrementOptionVote_Call{Call: _e.mock.On("IncrementOptionVote", ctx, optionID)}
}

func (_c *MockRepository_IncrementOptionVote_Call) Run(run func(ctx context.Context, optionID int)) *MockRepository_IncrementOptionVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_IncrementOptionVote_Call) Return(_a0 error) *MockRepository_IncrementOptionVote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_IncrementOptionVote_Call) RunAndReturn(run func(context.Context, int) error) *MockRepository_IncrementOptionVote_Call {
	_c.Call.Return(run)
	return _c
}

// IsNodeUnlocked provides a mock function with given fields: ctx, nodeKey, level
func (_m *MockRepository) IsNodeUnlocked(ctx context.Context, nodeKey string, level int) (bool, error) {
	ret := _m.Called(ctx, nodeKey, level)

	if len(ret) == 0 {
		panic("no return value specified for IsNodeUnlocked")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) (bool, error)); ok {
		return rf(ctx, nodeKey, level)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) bool); ok {
		r0 = rf(ctx, nodeKey, level)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, nodeKey, level)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_IsNodeUnlocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsNodeUnlocked'
type MockRepository_IsNodeUnlocked_Call struct {
	*mock.Call
}

// IsNodeUnlocked is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeKey string
//   - level int
func (_e *MockRepository_Expecter) IsNodeUnlocked(ctx interface{}, nodeKey interface{}, level interface{}) *MockRepository_IsNodeUnlocked_Call {
	return &MockRepository_IsNodeUnlocked_Call{Call: _e.mock.On("IsNodeUnlocked", ctx, nodeKey, level)}
}

func (_c *MockRepository_IsNodeUnlocked_Call) Run(run func(ctx context.Context, nodeKey string, level int)) *MockRepository_IsNodeUnlocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_IsNodeUnlocked_Call) Return(_a0 bool, _a1 error) *MockRepository_IsNodeUnlocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_IsNodeUnlocked_Call) RunAndReturn(run func(context.Context, string, int) (bool, error)) *MockRepository_IsNodeUnlocked_Call {
	_c.Call.Return(run)
	return _c
}

// IsUserProgressionUnlocked provides a mock function with given fields: ctx, userID, progressionType, key
func (_m *MockRepository) IsUserProgressionUnlocked(ctx context.Context, userID string, progressionType string, key string) (bool, error) {
	ret := _m.Called(ctx, userID, progressionType, key)

	if len(ret) == 0 {
		panic("no return value specified for IsUserProgressionUnlocked")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) (bool, error)); ok {
		return rf(ctx, userID, progressionType, key)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string) bool); ok {
		r0 = rf(ctx, userID, progressionType, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, string) error); ok {
		r1 = rf(ctx, userID, progressionType, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockRepository_IsUserProgressionUnlocked_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IsUserProgressionUnlocked'
type MockRepository_IsUserProgressionUnlocked_Call struct {
	*mock.Call
}

// IsUserProgressionUnlocked is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - progressionType string
//   - key string
func (_e *MockRepository_Expecter) IsUserProgressionUnlocked(ctx interface{}, userID interface{}, progressionType interface{}, key interface{}) *MockRepository_IsUserProgressionUnlocked_Call {
	return &MockRepository_IsUserProgressionUnlocked_Call{Call: _e.mock.On("IsUserProgressionUnlocked", ctx, userID, progressionType, key)}
}

func (_c *MockRepository_IsUserProgressionUnlocked_Call) Run(run func(ctx context.Context, userID string, progressionType string, key string)) *MockRepository_IsUserProgressionUnlocked_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockRepository_IsUserProgressionUnlocked_Call) Return(_a0 bool, _a1 error) *MockRepository_IsUserProgressionUnlocked_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockRepository_IsUserProgressionUnlocked_Call) RunAndReturn(run func(context.Context, string, string, string) (bool, error)) *MockRepository_IsUserProgressionUnlocked_Call {
	_c.Call.Return(run)
	return _c
}

// RecordEngagement provides a mock function with given fields: ctx, metric
func (_m *MockRepository) RecordEngagement(ctx context.Context, metric *domain.EngagementMetric) error {
	ret := _m.Called(ctx, metric)

	if len(ret) == 0 {
		panic("no return value specified for RecordEngagement")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.EngagementMetric) error); ok {
		r0 = rf(ctx, metric)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_RecordEngagement_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordEngagement'
type MockRepository_RecordEngagement_Call struct {
	*mock.Call
}

// RecordEngagement is a helper method to define mock.On call
//   - ctx context.Context
//   - metric *domain.EngagementMetric
func (_e *MockRepository_Expecter) RecordEngagement(ctx interface{}, metric interface{}) *MockRepository_RecordEngagement_Call {
	return &MockRepository_RecordEngagement_Call{Call: _e.mock.On("RecordEngagement", ctx, metric)}
}

func (_c *MockRepository_RecordEngagement_Call) Run(run func(ctx context.Context, metric *domain.EngagementMetric)) *MockRepository_RecordEngagement_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.EngagementMetric))
	})
	return _c
}

func (_c *MockRepository_RecordEngagement_Call) Return(_a0 error) *MockRepository_RecordEngagement_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_RecordEngagement_Call) RunAndReturn(run func(context.Context, *domain.EngagementMetric) error) *MockRepository_RecordEngagement_Call {
	_c.Call.Return(run)
	return _c
}

// RecordReset provides a mock function with given fields: ctx, reset
func (_m *MockRepository) RecordReset(ctx context.Context, reset *domain.ProgressionReset) error {
	ret := _m.Called(ctx, reset)

	if len(ret) == 0 {
		panic("no return value specified for RecordReset")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.ProgressionReset) error); ok {
		r0 = rf(ctx, reset)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_RecordReset_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordReset'
type MockRepository_RecordReset_Call struct {
	*mock.Call
}

// RecordReset is a helper method to define mock.On call
//   - ctx context.Context
//   - reset *domain.ProgressionReset
func (_e *MockRepository_Expecter) RecordReset(ctx interface{}, reset interface{}) *MockRepository_RecordReset_Call {
	return &MockRepository_RecordReset_Call{Call: _e.mock.On("RecordReset", ctx, reset)}
}

func (_c *MockRepository_RecordReset_Call) Run(run func(ctx context.Context, reset *domain.ProgressionReset)) *MockRepository_RecordReset_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.ProgressionReset))
	})
	return _c
}

func (_c *MockRepository_RecordReset_Call) Return(_a0 error) *MockRepository_RecordReset_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_RecordReset_Call) RunAndReturn(run func(context.Context, *domain.ProgressionReset) error) *MockRepository_RecordReset_Call {
	_c.Call.Return(run)
	return _c
}

// RecordUserSessionVote provides a mock function with given fields: ctx, userID, sessionID, optionID, nodeID
func (_m *MockRepository) RecordUserSessionVote(ctx context.Context, userID string, sessionID int, optionID int, nodeID int) error {
	ret := _m.Called(ctx, userID, sessionID, optionID, nodeID)

	if len(ret) == 0 {
		panic("no return value specified for RecordUserSessionVote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int, int, int) error); ok {
		r0 = rf(ctx, userID, sessionID, optionID, nodeID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_RecordUserSessionVote_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordUserSessionVote'
type MockRepository_RecordUserSessionVote_Call struct {
	*mock.Call
}

// RecordUserSessionVote is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - sessionID int
//   - optionID int
//   - nodeID int
func (_e *MockRepository_Expecter) RecordUserSessionVote(ctx interface{}, userID interface{}, sessionID interface{}, optionID interface{}, nodeID interface{}) *MockRepository_RecordUserSessionVote_Call {
	return &MockRepository_RecordUserSessionVote_Call{Call: _e.mock.On("RecordUserSessionVote", ctx, userID, sessionID, optionID, nodeID)}
}

func (_c *MockRepository_RecordUserSessionVote_Call) Run(run func(ctx context.Context, userID string, sessionID int, optionID int, nodeID int)) *MockRepository_RecordUserSessionVote_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(int), args[3].(int), args[4].(int))
	})
	return _c
}

func (_c *MockRepository_RecordUserSessionVote_Call) Return(_a0 error) *MockRepository_RecordUserSessionVote_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_RecordUserSessionVote_Call) RunAndReturn(run func(context.Context, string, int, int, int) error) *MockRepository_RecordUserSessionVote_Call {
	_c.Call.Return(run)
	return _c
}

// RelockNode provides a mock function with given fields: ctx, nodeID, level
func (_m *MockRepository) RelockNode(ctx context.Context, nodeID int, level int) error {
	ret := _m.Called(ctx, nodeID, level)

	if len(ret) == 0 {
		panic("no return value specified for RelockNode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int) error); ok {
		r0 = rf(ctx, nodeID, level)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_RelockNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RelockNode'
type MockRepository_RelockNode_Call struct {
	*mock.Call
}

// RelockNode is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID int
//   - level int
func (_e *MockRepository_Expecter) RelockNode(ctx interface{}, nodeID interface{}, level interface{}) *MockRepository_RelockNode_Call {
	return &MockRepository_RelockNode_Call{Call: _e.mock.On("RelockNode", ctx, nodeID, level)}
}

func (_c *MockRepository_RelockNode_Call) Run(run func(ctx context.Context, nodeID int, level int)) *MockRepository_RelockNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int))
	})
	return _c
}

func (_c *MockRepository_RelockNode_Call) Return(_a0 error) *MockRepository_RelockNode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_RelockNode_Call) RunAndReturn(run func(context.Context, int, int) error) *MockRepository_RelockNode_Call {
	_c.Call.Return(run)
	return _c
}

// ResetTree provides a mock function with given fields: ctx, resetBy, reason, preserveUserData
func (_m *MockRepository) ResetTree(ctx context.Context, resetBy string, reason string, preserveUserData bool) error {
	ret := _m.Called(ctx, resetBy, reason, preserveUserData)

	if len(ret) == 0 {
		panic("no return value specified for ResetTree")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, bool) error); ok {
		r0 = rf(ctx, resetBy, reason, preserveUserData)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_ResetTree_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResetTree'
type MockRepository_ResetTree_Call struct {
	*mock.Call
}

// ResetTree is a helper method to define mock.On call
//   - ctx context.Context
//   - resetBy string
//   - reason string
//   - preserveUserData bool
func (_e *MockRepository_Expecter) ResetTree(ctx interface{}, resetBy interface{}, reason interface{}, preserveUserData interface{}) *MockRepository_ResetTree_Call {
	return &MockRepository_ResetTree_Call{Call: _e.mock.On("ResetTree", ctx, resetBy, reason, preserveUserData)}
}

func (_c *MockRepository_ResetTree_Call) Run(run func(ctx context.Context, resetBy string, reason string, preserveUserData bool)) *MockRepository_ResetTree_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(bool))
	})
	return _c
}

func (_c *MockRepository_ResetTree_Call) Return(_a0 error) *MockRepository_ResetTree_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_ResetTree_Call) RunAndReturn(run func(context.Context, string, string, bool) error) *MockRepository_ResetTree_Call {
	_c.Call.Return(run)
	return _c
}

// ResumeVotingSession provides a mock function with given fields: ctx, sessionID
func (_m *MockRepository) ResumeVotingSession(ctx context.Context, sessionID int) error {
	ret := _m.Called(ctx, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for ResumeVotingSession")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int) error); ok {
		r0 = rf(ctx, sessionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_ResumeVotingSession_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ResumeVotingSession'
type MockRepository_ResumeVotingSession_Call struct {
	*mock.Call
}

// ResumeVotingSession is a helper method to define mock.On call
//   - ctx context.Context
//   - sessionID int
func (_e *MockRepository_Expecter) ResumeVotingSession(ctx interface{}, sessionID interface{}) *MockRepository_ResumeVotingSession_Call {
	return &MockRepository_ResumeVotingSession_Call{Call: _e.mock.On("ResumeVotingSession", ctx, sessionID)}
}

func (_c *MockRepository_ResumeVotingSession_Call) Run(run func(ctx context.Context, sessionID int)) *MockRepository_ResumeVotingSession_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int))
	})
	return _c
}

func (_c *MockRepository_ResumeVotingSession_Call) Return(_a0 error) *MockRepository_ResumeVotingSession_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_ResumeVotingSession_Call) RunAndReturn(run func(context.Context, int) error) *MockRepository_ResumeVotingSession_Call {
	_c.Call.Return(run)
	return _c
}

// SetUnlockTarget provides a mock function with given fields: ctx, progressID, nodeID, targetLevel, sessionID
func (_m *MockRepository) SetUnlockTarget(ctx context.Context, progressID int, nodeID int, targetLevel int, sessionID int) error {
	ret := _m.Called(ctx, progressID, nodeID, targetLevel, sessionID)

	if len(ret) == 0 {
		panic("no return value specified for SetUnlockTarget")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, int, int) error); ok {
		r0 = rf(ctx, progressID, nodeID, targetLevel, sessionID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_SetUnlockTarget_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetUnlockTarget'
type MockRepository_SetUnlockTarget_Call struct {
	*mock.Call
}

// SetUnlockTarget is a helper method to define mock.On call
//   - ctx context.Context
//   - progressID int
//   - nodeID int
//   - targetLevel int
//   - sessionID int
func (_e *MockRepository_Expecter) SetUnlockTarget(ctx interface{}, progressID interface{}, nodeID interface{}, targetLevel interface{}, sessionID interface{}) *MockRepository_SetUnlockTarget_Call {
	return &MockRepository_SetUnlockTarget_Call{Call: _e.mock.On("SetUnlockTarget", ctx, progressID, nodeID, targetLevel, sessionID)}
}

func (_c *MockRepository_SetUnlockTarget_Call) Run(run func(ctx context.Context, progressID int, nodeID int, targetLevel int, sessionID int)) *MockRepository_SetUnlockTarget_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(int), args[4].(int))
	})
	return _c
}

func (_c *MockRepository_SetUnlockTarget_Call) Return(_a0 error) *MockRepository_SetUnlockTarget_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_SetUnlockTarget_Call) RunAndReturn(run func(context.Context, int, int, int, int) error) *MockRepository_SetUnlockTarget_Call {
	_c.Call.Return(run)
	return _c
}

// UnlockNode provides a mock function with given fields: ctx, nodeID, level, unlockedBy, engagementScore
func (_m *MockRepository) UnlockNode(ctx context.Context, nodeID int, level int, unlockedBy string, engagementScore int) error {
	ret := _m.Called(ctx, nodeID, level, unlockedBy, engagementScore)

	if len(ret) == 0 {
		panic("no return value specified for UnlockNode")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, int, string, int) error); ok {
		r0 = rf(ctx, nodeID, level, unlockedBy, engagementScore)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_UnlockNode_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlockNode'
type MockRepository_UnlockNode_Call struct {
	*mock.Call
}

// UnlockNode is a helper method to define mock.On call
//   - ctx context.Context
//   - nodeID int
//   - level int
//   - unlockedBy string
//   - engagementScore int
func (_e *MockRepository_Expecter) UnlockNode(ctx interface{}, nodeID interface{}, level interface{}, unlockedBy interface{}, engagementScore interface{}) *MockRepository_UnlockNode_Call {
	return &MockRepository_UnlockNode_Call{Call: _e.mock.On("UnlockNode", ctx, nodeID, level, unlockedBy, engagementScore)}
}

func (_c *MockRepository_UnlockNode_Call) Run(run func(ctx context.Context, nodeID int, level int, unlockedBy string, engagementScore int)) *MockRepository_UnlockNode_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(int), args[2].(int), args[3].(string), args[4].(int))
	})
	return _c
}

func (_c *MockRepository_UnlockNode_Call) Return(_a0 error) *MockRepository_UnlockNode_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_UnlockNode_Call) RunAndReturn(run func(context.Context, int, int, string, int) error) *MockRepository_UnlockNode_Call {
	_c.Call.Return(run)
	return _c
}

// UnlockUserProgression provides a mock function with given fields: ctx, userID, progressionType, key, metadata
func (_m *MockRepository) UnlockUserProgression(ctx context.Context, userID string, progressionType string, key string, metadata map[string]interface{}) error {
	ret := _m.Called(ctx, userID, progressionType, key, metadata)

	if len(ret) == 0 {
		panic("no return value specified for UnlockUserProgression")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, string, map[string]interface{}) error); ok {
		r0 = rf(ctx, userID, progressionType, key, metadata)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_UnlockUserProgression_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnlockUserProgression'
type MockRepository_UnlockUserProgression_Call struct {
	*mock.Call
}

// UnlockUserProgression is a helper method to define mock.On call
//   - ctx context.Context
//   - userID string
//   - progressionType string
//   - key string
//   - metadata map[string]interface{}
func (_e *MockRepository_Expecter) UnlockUserProgression(ctx interface{}, userID interface{}, progressionType interface{}, key interface{}, metadata interface{}) *MockRepository_UnlockUserProgression_Call {
	return &MockRepository_UnlockUserProgression_Call{Call: _e.mock.On("UnlockUserProgression", ctx, userID, progressionType, key, metadata)}
}

func (_c *MockRepository_UnlockUserProgression_Call) Run(run func(ctx context.Context, userID string, progressionType string, key string, metadata map[string]interface{})) *MockRepository_UnlockUserProgression_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(string), args[4].(map[string]interface{}))
	})
	return _c
}

func (_c *MockRepository_UnlockUserProgression_Call) Return(_a0 error) *MockRepository_UnlockUserProgression_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_UnlockUserProgression_Call) RunAndReturn(run func(context.Context, string, string, string, map[string]interface{}) error) *MockRepository_UnlockUserProgression_Call {
	_c.Call.Return(run)
	return _c
}

// UpsertSyncMetadata provides a mock function with given fields: ctx, metadata
func (_m *MockRepository) UpsertSyncMetadata(ctx context.Context, metadata *domain.SyncMetadata) error {
	ret := _m.Called(ctx, metadata)

	if len(ret) == 0 {
		panic("no return value specified for UpsertSyncMetadata")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *domain.SyncMetadata) error); ok {
		r0 = rf(ctx, metadata)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockRepository_UpsertSyncMetadata_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpsertSyncMetadata'
type MockRepository_UpsertSyncMetadata_Call struct {
	*mock.Call
}

// UpsertSyncMetadata is a helper method to define mock.On call
//   - ctx context.Context
//   - metadata *domain.SyncMetadata
func (_e *MockRepository_Expecter) UpsertSyncMetadata(ctx interface{}, metadata interface{}) *MockRepository_UpsertSyncMetadata_Call {
	return &MockRepository_UpsertSyncMetadata_Call{Call: _e.mock.On("UpsertSyncMetadata", ctx, metadata)}
}

func (_c *MockRepository_UpsertSyncMetadata_Call) Run(run func(ctx context.Context, metadata *domain.SyncMetadata)) *MockRepository_UpsertSyncMetadata_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*domain.SyncMetadata))
	})
	return _c
}

func (_c *MockRepository_UpsertSyncMetadata_Call) Return(_a0 error) *MockRepository_UpsertSyncMetadata_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockRepository_UpsertSyncMetadata_Call) RunAndReturn(run func(context.Context, *domain.SyncMetadata) error) *MockRepository_UpsertSyncMetadata_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockRepository creates a new instance of MockRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockRepository {
	mock := &MockRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
