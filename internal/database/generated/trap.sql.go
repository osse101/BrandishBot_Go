// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: trap.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupStaleTraps = `-- name: CleanupStaleTraps :exec
DELETE FROM user_traps
WHERE triggered_at IS NULL AND placed_at < NOW() - INTERVAL '1 day' * $1
`

func (q *Queries) CleanupStaleTraps(ctx context.Context, dollar_1 interface{}) error {
	_, err := q.db.Exec(ctx, cleanupStaleTraps, dollar_1)
	return err
}

const createTrap = `-- name: CreateTrap :one
INSERT INTO user_traps (id, setter_id, target_id, quality_level, timeout_seconds, placed_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, setter_id, target_id, quality_level, timeout_seconds, placed_at, triggered_at
`

type CreateTrapParams struct {
	ID             uuid.UUID          `json:"id"`
	SetterID       uuid.UUID          `json:"setter_id"`
	TargetID       uuid.UUID          `json:"target_id"`
	QualityLevel   string             `json:"quality_level"`
	TimeoutSeconds int32              `json:"timeout_seconds"`
	PlacedAt       pgtype.Timestamptz `json:"placed_at"`
}

func (q *Queries) CreateTrap(ctx context.Context, arg CreateTrapParams) (UserTrap, error) {
	row := q.db.QueryRow(ctx, createTrap,
		arg.ID,
		arg.SetterID,
		arg.TargetID,
		arg.QualityLevel,
		arg.TimeoutSeconds,
		arg.PlacedAt,
	)
	var i UserTrap
	err := row.Scan(
		&i.ID,
		&i.SetterID,
		&i.TargetID,
		&i.QualityLevel,
		&i.TimeoutSeconds,
		&i.PlacedAt,
		&i.TriggeredAt,
	)
	return i, err
}

const getActiveTrap = `-- name: GetActiveTrap :one
SELECT id, setter_id, target_id, quality_level, timeout_seconds, placed_at, triggered_at
FROM user_traps
WHERE target_id = $1 AND triggered_at IS NULL
LIMIT 1
`

func (q *Queries) GetActiveTrap(ctx context.Context, targetID uuid.UUID) (UserTrap, error) {
	row := q.db.QueryRow(ctx, getActiveTrap, targetID)
	var i UserTrap
	err := row.Scan(
		&i.ID,
		&i.SetterID,
		&i.TargetID,
		&i.QualityLevel,
		&i.TimeoutSeconds,
		&i.PlacedAt,
		&i.TriggeredAt,
	)
	return i, err
}

const getActiveTrapForUpdate = `-- name: GetActiveTrapForUpdate :one
SELECT id, setter_id, target_id, quality_level, timeout_seconds, placed_at, triggered_at
FROM user_traps
WHERE target_id = $1 AND triggered_at IS NULL
LIMIT 1
FOR UPDATE
`

func (q *Queries) GetActiveTrapForUpdate(ctx context.Context, targetID uuid.UUID) (UserTrap, error) {
	row := q.db.QueryRow(ctx, getActiveTrapForUpdate, targetID)
	var i UserTrap
	err := row.Scan(
		&i.ID,
		&i.SetterID,
		&i.TargetID,
		&i.QualityLevel,
		&i.TimeoutSeconds,
		&i.PlacedAt,
		&i.TriggeredAt,
	)
	return i, err
}

const getTrapsByUser = `-- name: GetTrapsByUser :many
SELECT id, setter_id, target_id, quality_level, timeout_seconds, placed_at, triggered_at
FROM user_traps
WHERE setter_id = $1
ORDER BY placed_at DESC
LIMIT $2
`

type GetTrapsByUserParams struct {
	SetterID uuid.UUID `json:"setter_id"`
	Limit    int32     `json:"limit"`
}

func (q *Queries) GetTrapsByUser(ctx context.Context, arg GetTrapsByUserParams) ([]UserTrap, error) {
	rows, err := q.db.Query(ctx, getTrapsByUser, arg.SetterID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTrap
	for rows.Next() {
		var i UserTrap
		if err := rows.Scan(
			&i.ID,
			&i.SetterID,
			&i.TargetID,
			&i.QualityLevel,
			&i.TimeoutSeconds,
			&i.PlacedAt,
			&i.TriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTriggeredTrapsForTarget = `-- name: GetTriggeredTrapsForTarget :many
SELECT id, setter_id, target_id, quality_level, timeout_seconds, placed_at, triggered_at
FROM user_traps
WHERE target_id = $1 AND triggered_at IS NOT NULL
ORDER BY triggered_at DESC
LIMIT $2
`

type GetTriggeredTrapsForTargetParams struct {
	TargetID uuid.UUID `json:"target_id"`
	Limit    int32     `json:"limit"`
}

func (q *Queries) GetTriggeredTrapsForTarget(ctx context.Context, arg GetTriggeredTrapsForTargetParams) ([]UserTrap, error) {
	rows, err := q.db.Query(ctx, getTriggeredTrapsForTarget, arg.TargetID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTrap
	for rows.Next() {
		var i UserTrap
		if err := rows.Scan(
			&i.ID,
			&i.SetterID,
			&i.TargetID,
			&i.QualityLevel,
			&i.TimeoutSeconds,
			&i.PlacedAt,
			&i.TriggeredAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const triggerTrap = `-- name: TriggerTrap :exec
UPDATE user_traps
SET triggered_at = NOW()
WHERE id = $1
`

func (q *Queries) TriggerTrap(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, triggerTrap, id)
	return err
}
