// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: crafting.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const clearDisassembleOutputs = `-- name: ClearDisassembleOutputs :exec
DELETE FROM disassemble_outputs
WHERE recipe_id = $1
`

func (q *Queries) ClearDisassembleOutputs(ctx context.Context, recipeID int32) error {
	_, err := q.db.Exec(ctx, clearDisassembleOutputs, recipeID)
	return err
}

const getAllCraftingRecipes = `-- name: GetAllCraftingRecipes :many

SELECT recipe_id, recipe_key, target_item_id, base_cost, created_at
FROM crafting_recipes
ORDER BY recipe_id
`

type GetAllCraftingRecipesRow struct {
	RecipeID     int32            `json:"recipe_id"`
	RecipeKey    string           `json:"recipe_key"`
	TargetItemID int32            `json:"target_item_id"`
	BaseCost     []byte           `json:"base_cost"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
}

// Crafting Recipe Repository Queries
func (q *Queries) GetAllCraftingRecipes(ctx context.Context) ([]GetAllCraftingRecipesRow, error) {
	rows, err := q.db.Query(ctx, getAllCraftingRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCraftingRecipesRow
	for rows.Next() {
		var i GetAllCraftingRecipesRow
		if err := rows.Scan(
			&i.RecipeID,
			&i.RecipeKey,
			&i.TargetItemID,
			&i.BaseCost,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllDisassembleRecipes = `-- name: GetAllDisassembleRecipes :many
SELECT recipe_id, recipe_key, source_item_id, quantity_consumed, created_at
FROM disassemble_recipes
ORDER BY recipe_id
`

type GetAllDisassembleRecipesRow struct {
	RecipeID         int32            `json:"recipe_id"`
	RecipeKey        string           `json:"recipe_key"`
	SourceItemID     int32            `json:"source_item_id"`
	QuantityConsumed int32            `json:"quantity_consumed"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetAllDisassembleRecipes(ctx context.Context) ([]GetAllDisassembleRecipesRow, error) {
	rows, err := q.db.Query(ctx, getAllDisassembleRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllDisassembleRecipesRow
	for rows.Next() {
		var i GetAllDisassembleRecipesRow
		if err := rows.Scan(
			&i.RecipeID,
			&i.RecipeKey,
			&i.SourceItemID,
			&i.QuantityConsumed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCraftingRecipeByKey = `-- name: GetCraftingRecipeByKey :one
SELECT recipe_id, recipe_key, target_item_id, base_cost, created_at
FROM crafting_recipes
WHERE recipe_key = $1
`

type GetCraftingRecipeByKeyRow struct {
	RecipeID     int32            `json:"recipe_id"`
	RecipeKey    string           `json:"recipe_key"`
	TargetItemID int32            `json:"target_item_id"`
	BaseCost     []byte           `json:"base_cost"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetCraftingRecipeByKey(ctx context.Context, recipeKey string) (GetCraftingRecipeByKeyRow, error) {
	row := q.db.QueryRow(ctx, getCraftingRecipeByKey, recipeKey)
	var i GetCraftingRecipeByKeyRow
	err := row.Scan(
		&i.RecipeID,
		&i.RecipeKey,
		&i.TargetItemID,
		&i.BaseCost,
		&i.CreatedAt,
	)
	return i, err
}

const getDisassembleRecipeByKey = `-- name: GetDisassembleRecipeByKey :one
SELECT recipe_id, recipe_key, source_item_id, quantity_consumed, created_at
FROM disassemble_recipes
WHERE recipe_key = $1
`

type GetDisassembleRecipeByKeyRow struct {
	RecipeID         int32            `json:"recipe_id"`
	RecipeKey        string           `json:"recipe_key"`
	SourceItemID     int32            `json:"source_item_id"`
	QuantityConsumed int32            `json:"quantity_consumed"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetDisassembleRecipeByKey(ctx context.Context, recipeKey string) (GetDisassembleRecipeByKeyRow, error) {
	row := q.db.QueryRow(ctx, getDisassembleRecipeByKey, recipeKey)
	var i GetDisassembleRecipeByKeyRow
	err := row.Scan(
		&i.RecipeID,
		&i.RecipeKey,
		&i.SourceItemID,
		&i.QuantityConsumed,
		&i.CreatedAt,
	)
	return i, err
}

const insertCraftingRecipe = `-- name: InsertCraftingRecipe :one
INSERT INTO crafting_recipes (recipe_key, target_item_id, base_cost)
VALUES ($1, $2, $3)
RETURNING recipe_id
`

type InsertCraftingRecipeParams struct {
	RecipeKey    string `json:"recipe_key"`
	TargetItemID int32  `json:"target_item_id"`
	BaseCost     []byte `json:"base_cost"`
}

func (q *Queries) InsertCraftingRecipe(ctx context.Context, arg InsertCraftingRecipeParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertCraftingRecipe, arg.RecipeKey, arg.TargetItemID, arg.BaseCost)
	var recipe_id int32
	err := row.Scan(&recipe_id)
	return recipe_id, err
}

const insertDisassembleOutput = `-- name: InsertDisassembleOutput :exec
INSERT INTO disassemble_outputs (recipe_id, item_id, quantity)
VALUES ($1, $2, $3)
`

type InsertDisassembleOutputParams struct {
	RecipeID int32 `json:"recipe_id"`
	ItemID   int32 `json:"item_id"`
	Quantity int32 `json:"quantity"`
}

func (q *Queries) InsertDisassembleOutput(ctx context.Context, arg InsertDisassembleOutputParams) error {
	_, err := q.db.Exec(ctx, insertDisassembleOutput, arg.RecipeID, arg.ItemID, arg.Quantity)
	return err
}

const insertDisassembleRecipe = `-- name: InsertDisassembleRecipe :one
INSERT INTO disassemble_recipes (recipe_key, source_item_id, quantity_consumed)
VALUES ($1, $2, $3)
RETURNING recipe_id
`

type InsertDisassembleRecipeParams struct {
	RecipeKey        string `json:"recipe_key"`
	SourceItemID     int32  `json:"source_item_id"`
	QuantityConsumed int32  `json:"quantity_consumed"`
}

func (q *Queries) InsertDisassembleRecipe(ctx context.Context, arg InsertDisassembleRecipeParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertDisassembleRecipe, arg.RecipeKey, arg.SourceItemID, arg.QuantityConsumed)
	var recipe_id int32
	err := row.Scan(&recipe_id)
	return recipe_id, err
}

const updateCraftingRecipe = `-- name: UpdateCraftingRecipe :exec
UPDATE crafting_recipes
SET recipe_key = $1, target_item_id = $2, base_cost = $3
WHERE recipe_id = $4
`

type UpdateCraftingRecipeParams struct {
	RecipeKey    string `json:"recipe_key"`
	TargetItemID int32  `json:"target_item_id"`
	BaseCost     []byte `json:"base_cost"`
	RecipeID     int32  `json:"recipe_id"`
}

func (q *Queries) UpdateCraftingRecipe(ctx context.Context, arg UpdateCraftingRecipeParams) error {
	_, err := q.db.Exec(ctx, updateCraftingRecipe,
		arg.RecipeKey,
		arg.TargetItemID,
		arg.BaseCost,
		arg.RecipeID,
	)
	return err
}

const updateDisassembleRecipe = `-- name: UpdateDisassembleRecipe :exec
UPDATE disassemble_recipes
SET recipe_key = $1, source_item_id = $2, quantity_consumed = $3
WHERE recipe_id = $4
`

type UpdateDisassembleRecipeParams struct {
	RecipeKey        string `json:"recipe_key"`
	SourceItemID     int32  `json:"source_item_id"`
	QuantityConsumed int32  `json:"quantity_consumed"`
	RecipeID         int32  `json:"recipe_id"`
}

func (q *Queries) UpdateDisassembleRecipe(ctx context.Context, arg UpdateDisassembleRecipeParams) error {
	_, err := q.db.Exec(ctx, updateDisassembleRecipe,
		arg.RecipeKey,
		arg.SourceItemID,
		arg.QuantityConsumed,
		arg.RecipeID,
	)
	return err
}

const upsertRecipeAssociation = `-- name: UpsertRecipeAssociation :exec
INSERT INTO recipe_associations (upgrade_recipe_id, disassemble_recipe_id)
VALUES ($1, $2)
ON CONFLICT (upgrade_recipe_id, disassemble_recipe_id) DO NOTHING
`

type UpsertRecipeAssociationParams struct {
	UpgradeRecipeID     int32 `json:"upgrade_recipe_id"`
	DisassembleRecipeID int32 `json:"disassemble_recipe_id"`
}

func (q *Queries) UpsertRecipeAssociation(ctx context.Context, arg UpsertRecipeAssociationParams) error {
	_, err := q.db.Exec(ctx, upsertRecipeAssociation, arg.UpgradeRecipeID, arg.DisassembleRecipeID)
	return err
}
