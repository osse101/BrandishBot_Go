// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stats_slots.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getSlotsLeaderboardByMegaJackpots = `-- name: GetSlotsLeaderboardByMegaJackpots :many
SELECT
    se.user_id,
    u.username,
    COUNT(*) as mega_jackpots_hit
FROM stats_events se
JOIN users u ON se.user_id = u.user_id
WHERE se.event_type = 'slots_mega_jackpot'
  AND se.created_at >= $1
  AND se.created_at <= $2
GROUP BY se.user_id, u.username
ORDER BY mega_jackpots_hit DESC
LIMIT $3
`

type GetSlotsLeaderboardByMegaJackpotsParams struct {
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	ResultLimit int32            `json:"result_limit"`
}

type GetSlotsLeaderboardByMegaJackpotsRow struct {
	UserID          pgtype.UUID `json:"user_id"`
	Username        string      `json:"username"`
	MegaJackpotsHit int64       `json:"mega_jackpots_hit"`
}

// Get top users by mega jackpots hit for a time period
func (q *Queries) GetSlotsLeaderboardByMegaJackpots(ctx context.Context, arg GetSlotsLeaderboardByMegaJackpotsParams) ([]GetSlotsLeaderboardByMegaJackpotsRow, error) {
	rows, err := q.db.Query(ctx, getSlotsLeaderboardByMegaJackpots, arg.StartTime, arg.EndTime, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSlotsLeaderboardByMegaJackpotsRow
	for rows.Next() {
		var i GetSlotsLeaderboardByMegaJackpotsRow
		if err := rows.Scan(&i.UserID, &i.Username, &i.MegaJackpotsHit); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsLeaderboardByProfit = `-- name: GetSlotsLeaderboardByProfit :many
SELECT
    se.user_id,
    u.username,
    COALESCE(SUM((se.event_data->>'payout_amount')::int) - SUM((se.event_data->>'bet_amount')::int), 0) as net_profit,
    COUNT(*) FILTER (WHERE se.event_type = 'slots_spin') as total_spins
FROM stats_events se
JOIN users u ON se.user_id = u.user_id
WHERE se.event_type = 'slots_spin'
  AND se.created_at >= $1
  AND se.created_at <= $2
GROUP BY se.user_id, u.username
ORDER BY net_profit DESC
LIMIT $3
`

type GetSlotsLeaderboardByProfitParams struct {
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	ResultLimit int32            `json:"result_limit"`
}

type GetSlotsLeaderboardByProfitRow struct {
	UserID     pgtype.UUID `json:"user_id"`
	Username   string      `json:"username"`
	NetProfit  interface{} `json:"net_profit"`
	TotalSpins int64       `json:"total_spins"`
}

// Get top users by net profit (total payout - total bet) for a time period
func (q *Queries) GetSlotsLeaderboardByProfit(ctx context.Context, arg GetSlotsLeaderboardByProfitParams) ([]GetSlotsLeaderboardByProfitRow, error) {
	rows, err := q.db.Query(ctx, getSlotsLeaderboardByProfit, arg.StartTime, arg.EndTime, arg.ResultLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSlotsLeaderboardByProfitRow
	for rows.Next() {
		var i GetSlotsLeaderboardByProfitRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.NetProfit,
			&i.TotalSpins,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSlotsLeaderboardByWinRate = `-- name: GetSlotsLeaderboardByWinRate :many
SELECT
    se.user_id,
    u.username,
    COUNT(*) FILTER (WHERE se.event_type = 'slots_spin') as total_spins,
    COUNT(*) FILTER (WHERE se.event_type = 'slots_win') as total_wins,
    CASE
        WHEN COUNT(*) FILTER (WHERE se.event_type = 'slots_spin') > 0
        THEN (COUNT(*) FILTER (WHERE se.event_type = 'slots_win')::float / COUNT(*) FILTER (WHERE se.event_type = 'slots_spin')::float * 100)
        ELSE 0
    END as win_rate
FROM stats_events se
JOIN users u ON se.user_id = u.user_id
WHERE se.event_type LIKE 'slots_%'
  AND se.created_at >= $1
  AND se.created_at <= $2
GROUP BY se.user_id, u.username
HAVING COUNT(*) FILTER (WHERE se.event_type = 'slots_spin') >= $3::int8
ORDER BY win_rate DESC
LIMIT $4
`

type GetSlotsLeaderboardByWinRateParams struct {
	StartTime   pgtype.Timestamp `json:"start_time"`
	EndTime     pgtype.Timestamp `json:"end_time"`
	MinSpins    int64            `json:"min_spins"`
	ResultLimit int32            `json:"result_limit"`
}

type GetSlotsLeaderboardByWinRateRow struct {
	UserID     pgtype.UUID `json:"user_id"`
	Username   string      `json:"username"`
	TotalSpins int64       `json:"total_spins"`
	TotalWins  int64       `json:"total_wins"`
	WinRate    int32       `json:"win_rate"`
}

// Get top users by win rate for a time period (minimum spins required)
func (q *Queries) GetSlotsLeaderboardByWinRate(ctx context.Context, arg GetSlotsLeaderboardByWinRateParams) ([]GetSlotsLeaderboardByWinRateRow, error) {
	rows, err := q.db.Query(ctx, getSlotsLeaderboardByWinRate,
		arg.StartTime,
		arg.EndTime,
		arg.MinSpins,
		arg.ResultLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSlotsLeaderboardByWinRateRow
	for rows.Next() {
		var i GetSlotsLeaderboardByWinRateRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.TotalSpins,
			&i.TotalWins,
			&i.WinRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSlotsStats = `-- name: GetUserSlotsStats :one
SELECT
    COUNT(*) FILTER (WHERE event_type = 'slots_spin') as total_spins,
    COUNT(*) FILTER (WHERE event_type = 'slots_win') as total_wins,
    COALESCE(SUM((event_data->>'bet_amount')::int) FILTER (WHERE event_type = 'slots_spin'), 0) as total_bet,
    COALESCE(SUM((event_data->>'payout_amount')::int) FILTER (WHERE event_type = 'slots_spin'), 0) as total_payout,
    COUNT(*) FILTER (WHERE event_type = 'slots_mega_jackpot') as mega_jackpots_hit,
    COALESCE(MAX((event_data->>'payout_amount')::int) FILTER (WHERE event_type = 'slots_spin'), 0) as biggest_win
FROM stats_events
WHERE user_id = $1
  AND created_at >= $2
  AND created_at <= $3
  AND event_type LIKE 'slots_%'
`

type GetUserSlotsStatsParams struct {
	UserID    pgtype.UUID      `json:"user_id"`
	StartTime pgtype.Timestamp `json:"start_time"`
	EndTime   pgtype.Timestamp `json:"end_time"`
}

type GetUserSlotsStatsRow struct {
	TotalSpins      int64       `json:"total_spins"`
	TotalWins       int64       `json:"total_wins"`
	TotalBet        interface{} `json:"total_bet"`
	TotalPayout     interface{} `json:"total_payout"`
	MegaJackpotsHit int64       `json:"mega_jackpots_hit"`
	BiggestWin      interface{} `json:"biggest_win"`
}

// Calculate aggregate slots statistics for a user within a time period
func (q *Queries) GetUserSlotsStats(ctx context.Context, arg GetUserSlotsStatsParams) (GetUserSlotsStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserSlotsStats, arg.UserID, arg.StartTime, arg.EndTime)
	var i GetUserSlotsStatsRow
	err := row.Scan(
		&i.TotalSpins,
		&i.TotalWins,
		&i.TotalBet,
		&i.TotalPayout,
		&i.MegaJackpotsHit,
		&i.BiggestWin,
	)
	return i, err
}
