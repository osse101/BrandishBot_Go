// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: linking.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const cleanupExpiredTokens = `-- name: CleanupExpiredTokens :exec
DELETE FROM link_tokens
WHERE expires_at < NOW() - INTERVAL '1 hour'
`

func (q *Queries) CleanupExpiredTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredTokens)
	return err
}

const createToken = `-- name: CreateToken :exec
INSERT INTO link_tokens (token, source_platform, source_platform_id, state, created_at, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
`

type CreateTokenParams struct {
	Token            string             `json:"token"`
	SourcePlatform   string             `json:"source_platform"`
	SourcePlatformID string             `json:"source_platform_id"`
	State            pgtype.Text        `json:"state"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ExpiresAt        pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) CreateToken(ctx context.Context, arg CreateTokenParams) error {
	_, err := q.db.Exec(ctx, createToken,
		arg.Token,
		arg.SourcePlatform,
		arg.SourcePlatformID,
		arg.State,
		arg.CreatedAt,
		arg.ExpiresAt,
	)
	return err
}

const getClaimedTokenForSource = `-- name: GetClaimedTokenForSource :one
SELECT token, source_platform, source_platform_id, 
       COALESCE(target_platform, '') AS target_platform,
       COALESCE(target_platform_id, '') AS target_platform_id,
       state, created_at, expires_at
FROM link_tokens
WHERE source_platform = $1 AND source_platform_id = $2 AND state = 'claimed'
ORDER BY created_at DESC
LIMIT 1
`

type GetClaimedTokenForSourceParams struct {
	SourcePlatform   string `json:"source_platform"`
	SourcePlatformID string `json:"source_platform_id"`
}

type GetClaimedTokenForSourceRow struct {
	Token            string             `json:"token"`
	SourcePlatform   string             `json:"source_platform"`
	SourcePlatformID string             `json:"source_platform_id"`
	TargetPlatform   string             `json:"target_platform"`
	TargetPlatformID string             `json:"target_platform_id"`
	State            pgtype.Text        `json:"state"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ExpiresAt        pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetClaimedTokenForSource(ctx context.Context, arg GetClaimedTokenForSourceParams) (GetClaimedTokenForSourceRow, error) {
	row := q.db.QueryRow(ctx, getClaimedTokenForSource, arg.SourcePlatform, arg.SourcePlatformID)
	var i GetClaimedTokenForSourceRow
	err := row.Scan(
		&i.Token,
		&i.SourcePlatform,
		&i.SourcePlatformID,
		&i.TargetPlatform,
		&i.TargetPlatformID,
		&i.State,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const getToken = `-- name: GetToken :one
SELECT token, source_platform, source_platform_id, 
       COALESCE(target_platform, '') AS target_platform,
       COALESCE(target_platform_id, '') AS target_platform_id,
       state, created_at, expires_at
FROM link_tokens
WHERE token = $1
`

type GetTokenRow struct {
	Token            string             `json:"token"`
	SourcePlatform   string             `json:"source_platform"`
	SourcePlatformID string             `json:"source_platform_id"`
	TargetPlatform   string             `json:"target_platform"`
	TargetPlatformID string             `json:"target_platform_id"`
	State            pgtype.Text        `json:"state"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	ExpiresAt        pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) GetToken(ctx context.Context, token string) (GetTokenRow, error) {
	row := q.db.QueryRow(ctx, getToken, token)
	var i GetTokenRow
	err := row.Scan(
		&i.Token,
		&i.SourcePlatform,
		&i.SourcePlatformID,
		&i.TargetPlatform,
		&i.TargetPlatformID,
		&i.State,
		&i.CreatedAt,
		&i.ExpiresAt,
	)
	return i, err
}

const invalidateTokensForSource = `-- name: InvalidateTokensForSource :exec
UPDATE link_tokens
SET state = 'expired'
WHERE source_platform = $1 AND source_platform_id = $2 AND state IN ('pending', 'claimed')
`

type InvalidateTokensForSourceParams struct {
	SourcePlatform   string `json:"source_platform"`
	SourcePlatformID string `json:"source_platform_id"`
}

func (q *Queries) InvalidateTokensForSource(ctx context.Context, arg InvalidateTokensForSourceParams) error {
	_, err := q.db.Exec(ctx, invalidateTokensForSource, arg.SourcePlatform, arg.SourcePlatformID)
	return err
}

const updateToken = `-- name: UpdateToken :exec
UPDATE link_tokens
SET target_platform = $2, target_platform_id = $3, state = $4
WHERE token = $1
`

type UpdateTokenParams struct {
	Token            string      `json:"token"`
	TargetPlatform   pgtype.Text `json:"target_platform"`
	TargetPlatformID pgtype.Text `json:"target_platform_id"`
	State            pgtype.Text `json:"state"`
}

func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) error {
	_, err := q.db.Exec(ctx, updateToken,
		arg.Token,
		arg.TargetPlatform,
		arg.TargetPlatformID,
		arg.State,
	)
	return err
}
