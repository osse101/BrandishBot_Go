// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: subscription.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const deleteSubscription = `-- name: DeleteSubscription :exec
DELETE FROM user_subscriptions
WHERE user_id = $1 AND platform = $2
`

type DeleteSubscriptionParams struct {
	UserID   uuid.UUID `json:"user_id"`
	Platform string    `json:"platform"`
}

func (q *Queries) DeleteSubscription(ctx context.Context, arg DeleteSubscriptionParams) error {
	_, err := q.db.Exec(ctx, deleteSubscription, arg.UserID, arg.Platform)
	return err
}

const getAllTiers = `-- name: GetAllTiers :many
SELECT tier_id, platform, tier_name, display_name, tier_level, created_at
FROM subscription_tiers
ORDER BY platform, tier_level
`

func (q *Queries) GetAllTiers(ctx context.Context) ([]SubscriptionTier, error) {
	rows, err := q.db.Query(ctx, getAllTiers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionTier
	for rows.Next() {
		var i SubscriptionTier
		if err := rows.Scan(
			&i.TierID,
			&i.Platform,
			&i.TierName,
			&i.DisplayName,
			&i.TierLevel,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpiringSubscriptions = `-- name: GetExpiringSubscriptions :many
SELECT
    us.user_id,
    us.platform,
    us.tier_id,
    us.status,
    us.subscribed_at,
    us.expires_at,
    us.last_verified_at,
    us.created_at,
    us.updated_at,
    st.tier_name,
    st.display_name,
    st.tier_level
FROM user_subscriptions us
JOIN subscription_tiers st ON us.tier_id = st.tier_id
WHERE us.status = 'active' AND us.expires_at < $1
ORDER BY us.expires_at
`

type GetExpiringSubscriptionsRow struct {
	UserID         uuid.UUID          `json:"user_id"`
	Platform       string             `json:"platform"`
	TierID         int32              `json:"tier_id"`
	Status         string             `json:"status"`
	SubscribedAt   pgtype.Timestamptz `json:"subscribed_at"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	LastVerifiedAt pgtype.Timestamptz `json:"last_verified_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	TierName       string             `json:"tier_name"`
	DisplayName    string             `json:"display_name"`
	TierLevel      int32              `json:"tier_level"`
}

func (q *Queries) GetExpiringSubscriptions(ctx context.Context, expiresAt pgtype.Timestamptz) ([]GetExpiringSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, getExpiringSubscriptions, expiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpiringSubscriptionsRow
	for rows.Next() {
		var i GetExpiringSubscriptionsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Platform,
			&i.TierID,
			&i.Status,
			&i.SubscribedAt,
			&i.ExpiresAt,
			&i.LastVerifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TierName,
			&i.DisplayName,
			&i.TierLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTierByPlatformAndName = `-- name: GetTierByPlatformAndName :one
SELECT tier_id, platform, tier_name, display_name, tier_level, created_at
FROM subscription_tiers
WHERE platform = $1 AND tier_name = $2
`

type GetTierByPlatformAndNameParams struct {
	Platform string `json:"platform"`
	TierName string `json:"tier_name"`
}

func (q *Queries) GetTierByPlatformAndName(ctx context.Context, arg GetTierByPlatformAndNameParams) (SubscriptionTier, error) {
	row := q.db.QueryRow(ctx, getTierByPlatformAndName, arg.Platform, arg.TierName)
	var i SubscriptionTier
	err := row.Scan(
		&i.TierID,
		&i.Platform,
		&i.TierName,
		&i.DisplayName,
		&i.TierLevel,
		&i.CreatedAt,
	)
	return i, err
}

const getUserSubscription = `-- name: GetUserSubscription :one
SELECT
    us.user_id,
    us.platform,
    us.tier_id,
    us.status,
    us.subscribed_at,
    us.expires_at,
    us.last_verified_at,
    us.created_at,
    us.updated_at,
    st.tier_name,
    st.display_name,
    st.tier_level
FROM user_subscriptions us
JOIN subscription_tiers st ON us.tier_id = st.tier_id
WHERE us.user_id = $1 AND us.platform = $2
`

type GetUserSubscriptionParams struct {
	UserID   uuid.UUID `json:"user_id"`
	Platform string    `json:"platform"`
}

type GetUserSubscriptionRow struct {
	UserID         uuid.UUID          `json:"user_id"`
	Platform       string             `json:"platform"`
	TierID         int32              `json:"tier_id"`
	Status         string             `json:"status"`
	SubscribedAt   pgtype.Timestamptz `json:"subscribed_at"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	LastVerifiedAt pgtype.Timestamptz `json:"last_verified_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	TierName       string             `json:"tier_name"`
	DisplayName    string             `json:"display_name"`
	TierLevel      int32              `json:"tier_level"`
}

func (q *Queries) GetUserSubscription(ctx context.Context, arg GetUserSubscriptionParams) (GetUserSubscriptionRow, error) {
	row := q.db.QueryRow(ctx, getUserSubscription, arg.UserID, arg.Platform)
	var i GetUserSubscriptionRow
	err := row.Scan(
		&i.UserID,
		&i.Platform,
		&i.TierID,
		&i.Status,
		&i.SubscribedAt,
		&i.ExpiresAt,
		&i.LastVerifiedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TierName,
		&i.DisplayName,
		&i.TierLevel,
	)
	return i, err
}

const getUserSubscriptionHistory = `-- name: GetUserSubscriptionHistory :many
SELECT
    history_id,
    user_id,
    platform,
    tier_id,
    event_type,
    subscribed_at,
    expires_at,
    metadata,
    created_at
FROM subscription_history
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2
`

type GetUserSubscriptionHistoryParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
}

func (q *Queries) GetUserSubscriptionHistory(ctx context.Context, arg GetUserSubscriptionHistoryParams) ([]SubscriptionHistory, error) {
	rows, err := q.db.Query(ctx, getUserSubscriptionHistory, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubscriptionHistory
	for rows.Next() {
		var i SubscriptionHistory
		if err := rows.Scan(
			&i.HistoryID,
			&i.UserID,
			&i.Platform,
			&i.TierID,
			&i.EventType,
			&i.SubscribedAt,
			&i.ExpiresAt,
			&i.Metadata,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserSubscriptions = `-- name: GetUserSubscriptions :many
SELECT
    us.user_id,
    us.platform,
    us.tier_id,
    us.status,
    us.subscribed_at,
    us.expires_at,
    us.last_verified_at,
    us.created_at,
    us.updated_at,
    st.tier_name,
    st.display_name,
    st.tier_level
FROM user_subscriptions us
JOIN subscription_tiers st ON us.tier_id = st.tier_id
WHERE us.user_id = $1
ORDER BY us.platform
`

type GetUserSubscriptionsRow struct {
	UserID         uuid.UUID          `json:"user_id"`
	Platform       string             `json:"platform"`
	TierID         int32              `json:"tier_id"`
	Status         string             `json:"status"`
	SubscribedAt   pgtype.Timestamptz `json:"subscribed_at"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	LastVerifiedAt pgtype.Timestamptz `json:"last_verified_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `json:"updated_at"`
	TierName       string             `json:"tier_name"`
	DisplayName    string             `json:"display_name"`
	TierLevel      int32              `json:"tier_level"`
}

func (q *Queries) GetUserSubscriptions(ctx context.Context, userID uuid.UUID) ([]GetUserSubscriptionsRow, error) {
	rows, err := q.db.Query(ctx, getUserSubscriptions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserSubscriptionsRow
	for rows.Next() {
		var i GetUserSubscriptionsRow
		if err := rows.Scan(
			&i.UserID,
			&i.Platform,
			&i.TierID,
			&i.Status,
			&i.SubscribedAt,
			&i.ExpiresAt,
			&i.LastVerifiedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TierName,
			&i.DisplayName,
			&i.TierLevel,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markSubscriptionExpired = `-- name: MarkSubscriptionExpired :exec
UPDATE user_subscriptions
SET status = 'expired', updated_at = NOW()
WHERE user_id = $1 AND platform = $2
`

type MarkSubscriptionExpiredParams struct {
	UserID   uuid.UUID `json:"user_id"`
	Platform string    `json:"platform"`
}

func (q *Queries) MarkSubscriptionExpired(ctx context.Context, arg MarkSubscriptionExpiredParams) error {
	_, err := q.db.Exec(ctx, markSubscriptionExpired, arg.UserID, arg.Platform)
	return err
}

const recordSubscriptionHistory = `-- name: RecordSubscriptionHistory :exec
INSERT INTO subscription_history (
    user_id,
    platform,
    tier_id,
    event_type,
    subscribed_at,
    expires_at,
    metadata
)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type RecordSubscriptionHistoryParams struct {
	UserID       uuid.UUID          `json:"user_id"`
	Platform     string             `json:"platform"`
	TierID       int32              `json:"tier_id"`
	EventType    string             `json:"event_type"`
	SubscribedAt pgtype.Timestamptz `json:"subscribed_at"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	Metadata     []byte             `json:"metadata"`
}

func (q *Queries) RecordSubscriptionHistory(ctx context.Context, arg RecordSubscriptionHistoryParams) error {
	_, err := q.db.Exec(ctx, recordSubscriptionHistory,
		arg.UserID,
		arg.Platform,
		arg.TierID,
		arg.EventType,
		arg.SubscribedAt,
		arg.ExpiresAt,
		arg.Metadata,
	)
	return err
}

const upsertSubscription = `-- name: UpsertSubscription :exec
INSERT INTO user_subscriptions (
    user_id,
    platform,
    tier_id,
    status,
    subscribed_at,
    expires_at,
    last_verified_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
ON CONFLICT (user_id, platform) DO UPDATE
SET
    tier_id = EXCLUDED.tier_id,
    status = EXCLUDED.status,
    subscribed_at = EXCLUDED.subscribed_at,
    expires_at = EXCLUDED.expires_at,
    last_verified_at = EXCLUDED.last_verified_at,
    updated_at = NOW()
`

type UpsertSubscriptionParams struct {
	UserID         uuid.UUID          `json:"user_id"`
	Platform       string             `json:"platform"`
	TierID         int32              `json:"tier_id"`
	Status         string             `json:"status"`
	SubscribedAt   pgtype.Timestamptz `json:"subscribed_at"`
	ExpiresAt      pgtype.Timestamptz `json:"expires_at"`
	LastVerifiedAt pgtype.Timestamptz `json:"last_verified_at"`
}

func (q *Queries) UpsertSubscription(ctx context.Context, arg UpsertSubscriptionParams) error {
	_, err := q.db.Exec(ctx, upsertSubscription,
		arg.UserID,
		arg.Platform,
		arg.TierID,
		arg.Status,
		arg.SubscribedAt,
		arg.ExpiresAt,
		arg.LastVerifiedAt,
	)
	return err
}
