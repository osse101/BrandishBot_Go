// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: job.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAllJobs = `-- name: GetAllJobs :many
SELECT id, job_key, display_name, description, associated_features, created_at
FROM jobs
ORDER BY id
`

func (q *Queries) GetAllJobs(ctx context.Context) ([]Job, error) {
	rows, err := q.db.Query(ctx, getAllJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Job
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.JobKey,
			&i.DisplayName,
			&i.Description,
			&i.AssociatedFeatures,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByKey = `-- name: GetJobByKey :one
SELECT id, job_key, display_name, description, associated_features, created_at
FROM jobs
WHERE job_key = $1
`

func (q *Queries) GetJobByKey(ctx context.Context, jobKey string) (Job, error) {
	row := q.db.QueryRow(ctx, getJobByKey, jobKey)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobKey,
		&i.DisplayName,
		&i.Description,
		&i.AssociatedFeatures,
		&i.CreatedAt,
	)
	return i, err
}

const getJobLevelBonuses = `-- name: GetJobLevelBonuses :many
SELECT id, job_id, min_level, bonus_type, bonus_value, description
FROM job_level_bonuses
WHERE job_id = $1 AND min_level <= $2
ORDER BY min_level DESC
`

type GetJobLevelBonusesParams struct {
	JobID    int32 `json:"job_id"`
	MinLevel int32 `json:"min_level"`
}

func (q *Queries) GetJobLevelBonuses(ctx context.Context, arg GetJobLevelBonusesParams) ([]JobLevelBonuse, error) {
	rows, err := q.db.Query(ctx, getJobLevelBonuses, arg.JobID, arg.MinLevel)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []JobLevelBonuse
	for rows.Next() {
		var i JobLevelBonuse
		if err := rows.Scan(
			&i.ID,
			&i.JobID,
			&i.MinLevel,
			&i.BonusType,
			&i.BonusValue,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserJob = `-- name: GetUserJob :one
SELECT user_id, job_id, current_xp, current_level, xp_gained_today, last_xp_gain
FROM user_jobs
WHERE user_id = $1 AND job_id = $2
`

type GetUserJobParams struct {
	UserID uuid.UUID `json:"user_id"`
	JobID  int32     `json:"job_id"`
}

func (q *Queries) GetUserJob(ctx context.Context, arg GetUserJobParams) (UserJob, error) {
	row := q.db.QueryRow(ctx, getUserJob, arg.UserID, arg.JobID)
	var i UserJob
	err := row.Scan(
		&i.UserID,
		&i.JobID,
		&i.CurrentXp,
		&i.CurrentLevel,
		&i.XpGainedToday,
		&i.LastXpGain,
	)
	return i, err
}

const getUserJobs = `-- name: GetUserJobs :many
SELECT user_id, job_id, current_xp, current_level, xp_gained_today, last_xp_gain
FROM user_jobs
WHERE user_id = $1
ORDER BY current_level DESC, current_xp DESC
`

func (q *Queries) GetUserJobs(ctx context.Context, userID uuid.UUID) ([]UserJob, error) {
	rows, err := q.db.Query(ctx, getUserJobs, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserJob
	for rows.Next() {
		var i UserJob
		if err := rows.Scan(
			&i.UserID,
			&i.JobID,
			&i.CurrentXp,
			&i.CurrentLevel,
			&i.XpGainedToday,
			&i.LastXpGain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserJobsByPlatform = `-- name: GetUserJobsByPlatform :many
SELECT uj.user_id, uj.job_id, uj.current_xp, uj.current_level, uj.xp_gained_today, uj.last_xp_gain
FROM user_jobs uj
JOIN user_platform_links upl ON uj.user_id = upl.user_id
JOIN platforms p ON upl.platform_id = p.platform_id
WHERE p.name = $1 AND upl.platform_user_id = $2
ORDER BY uj.current_level DESC, uj.current_xp DESC
`

type GetUserJobsByPlatformParams struct {
	Name           string `json:"name"`
	PlatformUserID string `json:"platform_user_id"`
}

func (q *Queries) GetUserJobsByPlatform(ctx context.Context, arg GetUserJobsByPlatformParams) ([]UserJob, error) {
	rows, err := q.db.Query(ctx, getUserJobsByPlatform, arg.Name, arg.PlatformUserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserJob
	for rows.Next() {
		var i UserJob
		if err := rows.Scan(
			&i.UserID,
			&i.JobID,
			&i.CurrentXp,
			&i.CurrentLevel,
			&i.XpGainedToday,
			&i.LastXpGain,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordJobXPEvent = `-- name: RecordJobXPEvent :exec
INSERT INTO job_xp_events (id, user_id, job_id, xp_amount, source_type, source_metadata, recorded_at)
VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type RecordJobXPEventParams struct {
	ID             uuid.UUID          `json:"id"`
	UserID         uuid.UUID          `json:"user_id"`
	JobID          int32              `json:"job_id"`
	XpAmount       int32              `json:"xp_amount"`
	SourceType     string             `json:"source_type"`
	SourceMetadata []byte             `json:"source_metadata"`
	RecordedAt     pgtype.Timestamptz `json:"recorded_at"`
}

func (q *Queries) RecordJobXPEvent(ctx context.Context, arg RecordJobXPEventParams) error {
	_, err := q.db.Exec(ctx, recordJobXPEvent,
		arg.ID,
		arg.UserID,
		arg.JobID,
		arg.XpAmount,
		arg.SourceType,
		arg.SourceMetadata,
		arg.RecordedAt,
	)
	return err
}

const resetDailyJobXP = `-- name: ResetDailyJobXP :execresult
UPDATE user_jobs
SET xp_gained_today = 0
`

func (q *Queries) ResetDailyJobXP(ctx context.Context) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, resetDailyJobXP)
}

const upsertUserJob = `-- name: UpsertUserJob :exec
INSERT INTO user_jobs (user_id, job_id, current_xp, current_level, xp_gained_today, last_xp_gain)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT (user_id, job_id)
DO UPDATE SET
    current_xp = EXCLUDED.current_xp,
    current_level = EXCLUDED.current_level,
    xp_gained_today = EXCLUDED.xp_gained_today,
    last_xp_gain = EXCLUDED.last_xp_gain
`

type UpsertUserJobParams struct {
	UserID        uuid.UUID          `json:"user_id"`
	JobID         int32              `json:"job_id"`
	CurrentXp     int64              `json:"current_xp"`
	CurrentLevel  int32              `json:"current_level"`
	XpGainedToday pgtype.Int8        `json:"xp_gained_today"`
	LastXpGain    pgtype.Timestamptz `json:"last_xp_gain"`
}

func (q *Queries) UpsertUserJob(ctx context.Context, arg UpsertUserJobParams) error {
	_, err := q.db.Exec(ctx, upsertUserJob,
		arg.UserID,
		arg.JobID,
		arg.CurrentXp,
		arg.CurrentLevel,
		arg.XpGainedToday,
		arg.LastXpGain,
	)
	return err
}
