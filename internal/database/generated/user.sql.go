// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: user.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, created_at, updated_at)
VALUES ($1, NOW(), NOW())
RETURNING user_id
`

func (q *Queries) CreateUser(ctx context.Context, username string) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, createUser, username)
	var user_id uuid.UUID
	err := row.Scan(&user_id)
	return user_id, err
}

const deleteInventory = `-- name: DeleteInventory :exec
DELETE FROM user_inventory WHERE user_id = $1
`

func (q *Queries) DeleteInventory(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteInventory, userID)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE user_id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteUser, userID)
	return err
}

const deleteUserPlatformLink = `-- name: DeleteUserPlatformLink :exec
DELETE FROM user_platform_links 
WHERE user_id = $1 
AND platform_id = (SELECT platform_id FROM platforms WHERE name = $2)
`

type DeleteUserPlatformLinkParams struct {
	UserID uuid.UUID `json:"user_id"`
	Name   string    `json:"name"`
}

func (q *Queries) DeleteUserPlatformLink(ctx context.Context, arg DeleteUserPlatformLinkParams) error {
	_, err := q.db.Exec(ctx, deleteUserPlatformLink, arg.UserID, arg.Name)
	return err
}

const ensureInventoryRow = `-- name: EnsureInventoryRow :exec
INSERT INTO user_inventory (user_id, inventory_data)
VALUES ($1, $2)
ON CONFLICT (user_id) DO NOTHING
`

type EnsureInventoryRowParams struct {
	UserID        uuid.UUID `json:"user_id"`
	InventoryData []byte    `json:"inventory_data"`
}

func (q *Queries) EnsureInventoryRow(ctx context.Context, arg EnsureInventoryRowParams) error {
	_, err := q.db.Exec(ctx, ensureInventoryRow, arg.UserID, arg.InventoryData)
	return err
}

const getAllItems = `-- name: GetAllItems :many
SELECT 
    i.item_id, i.internal_name, i.public_name, i.default_display, i.item_description, i.base_value, i.handler,
    i.content_type,
    COALESCE(array_agg(t.type_name) FILTER (WHERE t.type_name IS NOT NULL), '{}')::text[] as types
FROM items i
LEFT JOIN item_type_assignments ita ON i.item_id = ita.item_id
LEFT JOIN item_types t ON ita.item_type_id = t.item_type_id
GROUP BY i.item_id
ORDER BY i.item_id
`

type GetAllItemsRow struct {
	ItemID          int32       `json:"item_id"`
	InternalName    string      `json:"internal_name"`
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
	Types           []string    `json:"types"`
}

func (q *Queries) GetAllItems(ctx context.Context) ([]GetAllItemsRow, error) {
	rows, err := q.db.Query(ctx, getAllItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllItemsRow
	for rows.Next() {
		var i GetAllItemsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.InternalName,
			&i.PublicName,
			&i.DefaultDisplay,
			&i.ItemDescription,
			&i.BaseValue,
			&i.Handler,
			&i.ContentType,
			&i.Types,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllRecipes = `-- name: GetAllRecipes :many
SELECT i.internal_name AS item_name, r.target_item_id AS item_id, i.item_description
FROM crafting_recipes r
JOIN items i ON r.target_item_id = i.item_id
ORDER BY i.internal_name
`

type GetAllRecipesRow struct {
	ItemName        string      `json:"item_name"`
	ItemID          int32       `json:"item_id"`
	ItemDescription pgtype.Text `json:"item_description"`
}

func (q *Queries) GetAllRecipes(ctx context.Context) ([]GetAllRecipesRow, error) {
	rows, err := q.db.Query(ctx, getAllRecipes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllRecipesRow
	for rows.Next() {
		var i GetAllRecipesRow
		if err := rows.Scan(&i.ItemName, &i.ItemID, &i.ItemDescription); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAssociatedUpgradeRecipeID = `-- name: GetAssociatedUpgradeRecipeID :one
SELECT upgrade_recipe_id
FROM recipe_associations
WHERE disassemble_recipe_id = $1
`

func (q *Queries) GetAssociatedUpgradeRecipeID(ctx context.Context, disassembleRecipeID int32) (int32, error) {
	row := q.db.QueryRow(ctx, getAssociatedUpgradeRecipeID, disassembleRecipeID)
	var upgrade_recipe_id int32
	err := row.Scan(&upgrade_recipe_id)
	return upgrade_recipe_id, err
}

const getBuyablePrices = `-- name: GetBuyablePrices :many
SELECT DISTINCT i.internal_name, i.public_name, i.base_value
FROM items i
INNER JOIN item_type_assignments ita ON i.item_id = ita.item_id
INNER JOIN item_types it ON ita.item_type_id = it.item_type_id
WHERE it.type_name = 'buyable' AND i.public_name IS NOT NULL
ORDER BY i.public_name
`

type GetBuyablePricesRow struct {
	InternalName string      `json:"internal_name"`
	PublicName   pgtype.Text `json:"public_name"`
	BaseValue    pgtype.Int4 `json:"base_value"`
}

func (q *Queries) GetBuyablePrices(ctx context.Context) ([]GetBuyablePricesRow, error) {
	rows, err := q.db.Query(ctx, getBuyablePrices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBuyablePricesRow
	for rows.Next() {
		var i GetBuyablePricesRow
		if err := rows.Scan(&i.InternalName, &i.PublicName, &i.BaseValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDisassembleOutputs = `-- name: GetDisassembleOutputs :many
SELECT item_id, quantity
FROM disassemble_outputs
WHERE recipe_id = $1
ORDER BY item_id
`

type GetDisassembleOutputsRow struct {
	ItemID   int32 `json:"item_id"`
	Quantity int32 `json:"quantity"`
}

func (q *Queries) GetDisassembleOutputs(ctx context.Context, recipeID int32) ([]GetDisassembleOutputsRow, error) {
	rows, err := q.db.Query(ctx, getDisassembleOutputs, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDisassembleOutputsRow
	for rows.Next() {
		var i GetDisassembleOutputsRow
		if err := rows.Scan(&i.ItemID, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDisassembleRecipeBySourceItemID = `-- name: GetDisassembleRecipeBySourceItemID :one
SELECT recipe_id, source_item_id, quantity_consumed, created_at
FROM disassemble_recipes
WHERE source_item_id = $1
`

type GetDisassembleRecipeBySourceItemIDRow struct {
	RecipeID         int32            `json:"recipe_id"`
	SourceItemID     int32            `json:"source_item_id"`
	QuantityConsumed int32            `json:"quantity_consumed"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetDisassembleRecipeBySourceItemID(ctx context.Context, sourceItemID int32) (GetDisassembleRecipeBySourceItemIDRow, error) {
	row := q.db.QueryRow(ctx, getDisassembleRecipeBySourceItemID, sourceItemID)
	var i GetDisassembleRecipeBySourceItemIDRow
	err := row.Scan(
		&i.RecipeID,
		&i.SourceItemID,
		&i.QuantityConsumed,
		&i.CreatedAt,
	)
	return i, err
}

const getInventory = `-- name: GetInventory :one
SELECT inventory_data FROM user_inventory WHERE user_id = $1
`

func (q *Queries) GetInventory(ctx context.Context, userID uuid.UUID) ([]byte, error) {
	row := q.db.QueryRow(ctx, getInventory, userID)
	var inventory_data []byte
	err := row.Scan(&inventory_data)
	return inventory_data, err
}

const getInventoryForUpdate = `-- name: GetInventoryForUpdate :one
SELECT inventory_data FROM user_inventory WHERE user_id = $1 FOR UPDATE
`

func (q *Queries) GetInventoryForUpdate(ctx context.Context, userID uuid.UUID) ([]byte, error) {
	row := q.db.QueryRow(ctx, getInventoryForUpdate, userID)
	var inventory_data []byte
	err := row.Scan(&inventory_data)
	return inventory_data, err
}

const getItemByID = `-- name: GetItemByID :one
SELECT 
    i.item_id, i.internal_name, i.public_name, i.default_display, i.item_description, i.base_value, i.handler,
    i.content_type,
    COALESCE(array_agg(t.type_name) FILTER (WHERE t.type_name IS NOT NULL), '{}')::text[] as types
FROM items i
LEFT JOIN item_type_assignments ita ON i.item_id = ita.item_id
LEFT JOIN item_types t ON ita.item_type_id = t.item_type_id
WHERE i.item_id = $1
GROUP BY i.item_id
`

type GetItemByIDRow struct {
	ItemID          int32       `json:"item_id"`
	InternalName    string      `json:"internal_name"`
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
	Types           []string    `json:"types"`
}

func (q *Queries) GetItemByID(ctx context.Context, itemID int32) (GetItemByIDRow, error) {
	row := q.db.QueryRow(ctx, getItemByID, itemID)
	var i GetItemByIDRow
	err := row.Scan(
		&i.ItemID,
		&i.InternalName,
		&i.PublicName,
		&i.DefaultDisplay,
		&i.ItemDescription,
		&i.BaseValue,
		&i.Handler,
		&i.ContentType,
		&i.Types,
	)
	return i, err
}

const getItemByName = `-- name: GetItemByName :one
SELECT 
    i.item_id, i.internal_name, i.public_name, i.default_display, i.item_description, i.base_value, i.handler,
    i.content_type,
    COALESCE(array_agg(t.type_name) FILTER (WHERE t.type_name IS NOT NULL), '{}')::text[] as types
FROM items i
LEFT JOIN item_type_assignments ita ON i.item_id = ita.item_id
LEFT JOIN item_types t ON ita.item_type_id = t.item_type_id
WHERE i.internal_name = $1
GROUP BY i.item_id
`

type GetItemByNameRow struct {
	ItemID          int32       `json:"item_id"`
	InternalName    string      `json:"internal_name"`
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
	Types           []string    `json:"types"`
}

func (q *Queries) GetItemByName(ctx context.Context, internalName string) (GetItemByNameRow, error) {
	row := q.db.QueryRow(ctx, getItemByName, internalName)
	var i GetItemByNameRow
	err := row.Scan(
		&i.ItemID,
		&i.InternalName,
		&i.PublicName,
		&i.DefaultDisplay,
		&i.ItemDescription,
		&i.BaseValue,
		&i.Handler,
		&i.ContentType,
		&i.Types,
	)
	return i, err
}

const getItemByPublicName = `-- name: GetItemByPublicName :one
SELECT 
    i.item_id, i.internal_name, i.public_name, i.default_display, i.item_description, i.base_value, i.handler,
    i.content_type,
    COALESCE(array_agg(t.type_name) FILTER (WHERE t.type_name IS NOT NULL), '{}')::text[] as types
FROM items i
LEFT JOIN item_type_assignments ita ON i.item_id = ita.item_id
LEFT JOIN item_types t ON ita.item_type_id = t.item_type_id
WHERE i.public_name = $1
GROUP BY i.item_id
`

type GetItemByPublicNameRow struct {
	ItemID          int32       `json:"item_id"`
	InternalName    string      `json:"internal_name"`
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
	Types           []string    `json:"types"`
}

func (q *Queries) GetItemByPublicName(ctx context.Context, publicName pgtype.Text) (GetItemByPublicNameRow, error) {
	row := q.db.QueryRow(ctx, getItemByPublicName, publicName)
	var i GetItemByPublicNameRow
	err := row.Scan(
		&i.ItemID,
		&i.InternalName,
		&i.PublicName,
		&i.DefaultDisplay,
		&i.ItemDescription,
		&i.BaseValue,
		&i.Handler,
		&i.ContentType,
		&i.Types,
	)
	return i, err
}

const getItemsByIDs = `-- name: GetItemsByIDs :many
SELECT 
    i.item_id, i.internal_name, i.public_name, i.default_display, i.item_description, i.base_value, i.handler,
    i.content_type,
    COALESCE(array_agg(t.type_name) FILTER (WHERE t.type_name IS NOT NULL), '{}')::text[] as types
FROM items i
LEFT JOIN item_type_assignments ita ON i.item_id = ita.item_id
LEFT JOIN item_types t ON ita.item_type_id = t.item_type_id
WHERE i.item_id = ANY($1::int[])
GROUP BY i.item_id
`

type GetItemsByIDsRow struct {
	ItemID          int32       `json:"item_id"`
	InternalName    string      `json:"internal_name"`
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
	Types           []string    `json:"types"`
}

func (q *Queries) GetItemsByIDs(ctx context.Context, dollar_1 []int32) ([]GetItemsByIDsRow, error) {
	rows, err := q.db.Query(ctx, getItemsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsByIDsRow
	for rows.Next() {
		var i GetItemsByIDsRow
		if err := rows.Scan(
			&i.ItemID,
			&i.InternalName,
			&i.PublicName,
			&i.DefaultDisplay,
			&i.ItemDescription,
			&i.BaseValue,
			&i.Handler,
			&i.ContentType,
			&i.Types,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsByNames = `-- name: GetItemsByNames :many
SELECT 
    i.item_id, i.internal_name, i.public_name, i.default_display, i.item_description, i.base_value, i.handler,
    i.content_type,
    COALESCE(array_agg(t.type_name) FILTER (WHERE t.type_name IS NOT NULL), '{}')::text[] as types
FROM items i
LEFT JOIN item_type_assignments ita ON i.item_id = ita.item_id
LEFT JOIN item_types t ON ita.item_type_id = t.item_type_id
WHERE i.internal_name = ANY($1::text[])
GROUP BY i.item_id
`

type GetItemsByNamesRow struct {
	ItemID          int32       `json:"item_id"`
	InternalName    string      `json:"internal_name"`
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
	Types           []string    `json:"types"`
}

func (q *Queries) GetItemsByNames(ctx context.Context, dollar_1 []string) ([]GetItemsByNamesRow, error) {
	rows, err := q.db.Query(ctx, getItemsByNames, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsByNamesRow
	for rows.Next() {
		var i GetItemsByNamesRow
		if err := rows.Scan(
			&i.ItemID,
			&i.InternalName,
			&i.PublicName,
			&i.DefaultDisplay,
			&i.ItemDescription,
			&i.BaseValue,
			&i.Handler,
			&i.ContentType,
			&i.Types,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastCooldown = `-- name: GetLastCooldown :one
SELECT last_used_at
FROM user_cooldowns
WHERE user_id = $1 AND action_name = $2
`

type GetLastCooldownParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ActionName string    `json:"action_name"`
}

func (q *Queries) GetLastCooldown(ctx context.Context, arg GetLastCooldownParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getLastCooldown, arg.UserID, arg.ActionName)
	var last_used_at pgtype.Timestamptz
	err := row.Scan(&last_used_at)
	return last_used_at, err
}

const getLastCooldownForUpdate = `-- name: GetLastCooldownForUpdate :one
SELECT last_used_at
FROM user_cooldowns
WHERE user_id = $1 AND action_name = $2
FOR UPDATE
`

type GetLastCooldownForUpdateParams struct {
	UserID     uuid.UUID `json:"user_id"`
	ActionName string    `json:"action_name"`
}

func (q *Queries) GetLastCooldownForUpdate(ctx context.Context, arg GetLastCooldownForUpdateParams) (pgtype.Timestamptz, error) {
	row := q.db.QueryRow(ctx, getLastCooldownForUpdate, arg.UserID, arg.ActionName)
	var last_used_at pgtype.Timestamptz
	err := row.Scan(&last_used_at)
	return last_used_at, err
}

const getPlatformID = `-- name: GetPlatformID :one
SELECT platform_id FROM platforms WHERE name = $1
`

func (q *Queries) GetPlatformID(ctx context.Context, name string) (int32, error) {
	row := q.db.QueryRow(ctx, getPlatformID, name)
	var platform_id int32
	err := row.Scan(&platform_id)
	return platform_id, err
}

const getRecipeByTargetItemID = `-- name: GetRecipeByTargetItemID :one
SELECT recipe_id, target_item_id, base_cost, created_at FROM crafting_recipes WHERE target_item_id = $1
`

type GetRecipeByTargetItemIDRow struct {
	RecipeID     int32            `json:"recipe_id"`
	TargetItemID int32            `json:"target_item_id"`
	BaseCost     []byte           `json:"base_cost"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetRecipeByTargetItemID(ctx context.Context, targetItemID int32) (GetRecipeByTargetItemIDRow, error) {
	row := q.db.QueryRow(ctx, getRecipeByTargetItemID, targetItemID)
	var i GetRecipeByTargetItemIDRow
	err := row.Scan(
		&i.RecipeID,
		&i.TargetItemID,
		&i.BaseCost,
		&i.CreatedAt,
	)
	return i, err
}

const getSellablePrices = `-- name: GetSellablePrices :many
SELECT DISTINCT i.internal_name, i.public_name, i.base_value
FROM items i
INNER JOIN item_type_assignments ita ON i.item_id = ita.item_id
INNER JOIN item_types it ON ita.item_type_id = it.item_type_id
WHERE it.type_name = 'sellable' AND i.public_name IS NOT NULL
ORDER BY i.public_name
`

type GetSellablePricesRow struct {
	InternalName string      `json:"internal_name"`
	PublicName   pgtype.Text `json:"public_name"`
	BaseValue    pgtype.Int4 `json:"base_value"`
}

func (q *Queries) GetSellablePrices(ctx context.Context) ([]GetSellablePricesRow, error) {
	rows, err := q.db.Query(ctx, getSellablePrices)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSellablePricesRow
	for rows.Next() {
		var i GetSellablePricesRow
		if err := rows.Scan(&i.InternalName, &i.PublicName, &i.BaseValue); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnlockedRecipesForUser = `-- name: GetUnlockedRecipesForUser :many
SELECT i.internal_name AS item_name, r.target_item_id AS item_id
FROM crafting_recipes r
JOIN recipe_unlocks ru ON r.recipe_id = ru.recipe_id
JOIN items i ON r.target_item_id = i.item_id
WHERE ru.user_id = $1
ORDER BY i.internal_name
`

type GetUnlockedRecipesForUserRow struct {
	ItemName string `json:"item_name"`
	ItemID   int32  `json:"item_id"`
}

func (q *Queries) GetUnlockedRecipesForUser(ctx context.Context, userID uuid.UUID) ([]GetUnlockedRecipesForUserRow, error) {
	rows, err := q.db.Query(ctx, getUnlockedRecipesForUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnlockedRecipesForUserRow
	for rows.Next() {
		var i GetUnlockedRecipesForUserRow
		if err := rows.Scan(&i.ItemName, &i.ItemID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByID = `-- name: GetUserByID :one
SELECT user_id, username, created_at, updated_at FROM users WHERE user_id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, userID)
	var i User
	err := row.Scan(
		&i.UserID,
		&i.Username,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByPlatformID = `-- name: GetUserByPlatformID :one
SELECT u.user_id, u.username
FROM users u
JOIN user_platform_links upl ON u.user_id = upl.user_id
JOIN platforms p ON upl.platform_id = p.platform_id
WHERE p.name = $1 AND upl.platform_user_id = $2
`

type GetUserByPlatformIDParams struct {
	Name           string `json:"name"`
	PlatformUserID string `json:"platform_user_id"`
}

type GetUserByPlatformIDRow struct {
	UserID   uuid.UUID `json:"user_id"`
	Username string    `json:"username"`
}

func (q *Queries) GetUserByPlatformID(ctx context.Context, arg GetUserByPlatformIDParams) (GetUserByPlatformIDRow, error) {
	row := q.db.QueryRow(ctx, getUserByPlatformID, arg.Name, arg.PlatformUserID)
	var i GetUserByPlatformIDRow
	err := row.Scan(&i.UserID, &i.Username)
	return i, err
}

const getUserByPlatformUsername = `-- name: GetUserByPlatformUsername :one
SELECT u.user_id, u.username
FROM users u
JOIN user_platform_links upl ON u.user_id = upl.user_id
JOIN platforms p ON upl.platform_id = p.platform_id
WHERE LOWER(u.username) = LOWER($1)
AND p.name = $2
`

type GetUserByPlatformUsernameParams struct {
	Lower string `json:"lower"`
	Name  string `json:"name"`
}

type GetUserByPlatformUsernameRow struct {
	UserID   uuid.UUID `json:"user_id"`
	Username string    `json:"username"`
}

func (q *Queries) GetUserByPlatformUsername(ctx context.Context, arg GetUserByPlatformUsernameParams) (GetUserByPlatformUsernameRow, error) {
	row := q.db.QueryRow(ctx, getUserByPlatformUsername, arg.Lower, arg.Name)
	var i GetUserByPlatformUsernameRow
	err := row.Scan(&i.UserID, &i.Username)
	return i, err
}

const getUserPlatformLinks = `-- name: GetUserPlatformLinks :many
SELECT p.name, upl.platform_user_id
FROM user_platform_links upl
JOIN platforms p ON upl.platform_id = p.platform_id
WHERE upl.user_id = $1
`

type GetUserPlatformLinksRow struct {
	Name           string `json:"name"`
	PlatformUserID string `json:"platform_user_id"`
}

func (q *Queries) GetUserPlatformLinks(ctx context.Context, userID uuid.UUID) ([]GetUserPlatformLinksRow, error) {
	rows, err := q.db.Query(ctx, getUserPlatformLinks, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserPlatformLinksRow
	for rows.Next() {
		var i GetUserPlatformLinksRow
		if err := rows.Scan(&i.Name, &i.PlatformUserID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isItemBuyable = `-- name: IsItemBuyable :one
SELECT EXISTS (
    SELECT 1
    FROM items i
    JOIN item_type_assignments ita ON i.item_id = ita.item_id
    JOIN item_types it ON ita.item_type_id = it.item_type_id
    WHERE i.internal_name = $1 AND it.type_name = 'buyable'
)
`

func (q *Queries) IsItemBuyable(ctx context.Context, internalName string) (bool, error) {
	row := q.db.QueryRow(ctx, isItemBuyable, internalName)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isRecipeUnlocked = `-- name: IsRecipeUnlocked :one
SELECT EXISTS (SELECT 1 FROM recipe_unlocks WHERE user_id = $1 AND recipe_id = $2)
`

type IsRecipeUnlockedParams struct {
	UserID   uuid.UUID `json:"user_id"`
	RecipeID int32     `json:"recipe_id"`
}

func (q *Queries) IsRecipeUnlocked(ctx context.Context, arg IsRecipeUnlockedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isRecipeUnlocked, arg.UserID, arg.RecipeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const unlockRecipe = `-- name: UnlockRecipe :exec
INSERT INTO recipe_unlocks (user_id, recipe_id, unlocked_at)
VALUES ($1, $2, NOW())
ON CONFLICT (user_id, recipe_id) DO NOTHING
`

type UnlockRecipeParams struct {
	UserID   uuid.UUID `json:"user_id"`
	RecipeID int32     `json:"recipe_id"`
}

func (q *Queries) UnlockRecipe(ctx context.Context, arg UnlockRecipeParams) error {
	_, err := q.db.Exec(ctx, unlockRecipe, arg.UserID, arg.RecipeID)
	return err
}

const updateCooldown = `-- name: UpdateCooldown :exec
INSERT INTO user_cooldowns (user_id, action_name, last_used_at)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, action_name) DO UPDATE
SET last_used_at = EXCLUDED.last_used_at
`

type UpdateCooldownParams struct {
	UserID     uuid.UUID          `json:"user_id"`
	ActionName string             `json:"action_name"`
	LastUsedAt pgtype.Timestamptz `json:"last_used_at"`
}

func (q *Queries) UpdateCooldown(ctx context.Context, arg UpdateCooldownParams) error {
	_, err := q.db.Exec(ctx, updateCooldown, arg.UserID, arg.ActionName, arg.LastUsedAt)
	return err
}

const updateInventory = `-- name: UpdateInventory :exec
INSERT INTO user_inventory (user_id, inventory_data)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE
SET inventory_data = EXCLUDED.inventory_data
`

type UpdateInventoryParams struct {
	UserID        uuid.UUID `json:"user_id"`
	InventoryData []byte    `json:"inventory_data"`
}

func (q *Queries) UpdateInventory(ctx context.Context, arg UpdateInventoryParams) error {
	_, err := q.db.Exec(ctx, updateInventory, arg.UserID, arg.InventoryData)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users 
SET username = $1, updated_at = NOW()
WHERE user_id = $2
`

type UpdateUserParams struct {
	Username string    `json:"username"`
	UserID   uuid.UUID `json:"user_id"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser, arg.Username, arg.UserID)
	return err
}

const updateUserTimestamp = `-- name: UpdateUserTimestamp :exec
UPDATE users SET updated_at = NOW() WHERE user_id = $1
`

func (q *Queries) UpdateUserTimestamp(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, updateUserTimestamp, userID)
	return err
}

const upsertUserPlatformLink = `-- name: UpsertUserPlatformLink :exec
INSERT INTO user_platform_links (user_id, platform_id, platform_user_id)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, platform_id) DO UPDATE
SET platform_user_id = EXCLUDED.platform_user_id
`

type UpsertUserPlatformLinkParams struct {
	UserID         uuid.UUID `json:"user_id"`
	PlatformID     int32     `json:"platform_id"`
	PlatformUserID string    `json:"platform_user_id"`
}

func (q *Queries) UpsertUserPlatformLink(ctx context.Context, arg UpsertUserPlatformLinkParams) error {
	_, err := q.db.Exec(ctx, upsertUserPlatformLink, arg.UserID, arg.PlatformID, arg.PlatformUserID)
	return err
}
