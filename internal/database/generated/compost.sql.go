// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: compost.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createCompostBin = `-- name: CreateCompostBin :one
INSERT INTO compost_bins (user_id) VALUES ($1) RETURNING id, user_id, status, capacity, items, item_count, started_at, ready_at, sludge_at, input_value, dominant_type, created_at, updated_at
`

func (q *Queries) CreateCompostBin(ctx context.Context, userID uuid.UUID) (CompostBin, error) {
	row := q.db.QueryRow(ctx, createCompostBin, userID)
	var i CompostBin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Capacity,
		&i.Items,
		&i.ItemCount,
		&i.StartedAt,
		&i.ReadyAt,
		&i.SludgeAt,
		&i.InputValue,
		&i.DominantType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompostBin = `-- name: GetCompostBin :one

SELECT id, user_id, status, capacity, items, item_count, started_at, ready_at, sludge_at, input_value, dominant_type, created_at, updated_at FROM compost_bins WHERE user_id = $1
`

// Compost Bin Queries
func (q *Queries) GetCompostBin(ctx context.Context, userID uuid.UUID) (CompostBin, error) {
	row := q.db.QueryRow(ctx, getCompostBin, userID)
	var i CompostBin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Capacity,
		&i.Items,
		&i.ItemCount,
		&i.StartedAt,
		&i.ReadyAt,
		&i.SludgeAt,
		&i.InputValue,
		&i.DominantType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCompostBinForUpdate = `-- name: GetCompostBinForUpdate :one
SELECT id, user_id, status, capacity, items, item_count, started_at, ready_at, sludge_at, input_value, dominant_type, created_at, updated_at FROM compost_bins WHERE user_id = $1 FOR UPDATE
`

func (q *Queries) GetCompostBinForUpdate(ctx context.Context, userID uuid.UUID) (CompostBin, error) {
	row := q.db.QueryRow(ctx, getCompostBinForUpdate, userID)
	var i CompostBin
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Status,
		&i.Capacity,
		&i.Items,
		&i.ItemCount,
		&i.StartedAt,
		&i.ReadyAt,
		&i.SludgeAt,
		&i.InputValue,
		&i.DominantType,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resetCompostBin = `-- name: ResetCompostBin :exec
UPDATE compost_bins SET
    status = 'idle',
    items = '[]'::jsonb,
    item_count = 0,
    started_at = NULL,
    ready_at = NULL,
    sludge_at = NULL,
    input_value = 0,
    dominant_type = '',
    updated_at = NOW()
WHERE user_id = $1
`

func (q *Queries) ResetCompostBin(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, resetCompostBin, userID)
	return err
}

const updateCompostBin = `-- name: UpdateCompostBin :exec
UPDATE compost_bins SET
    status = $2,
    items = $3,
    item_count = $4,
    started_at = $5,
    ready_at = $6,
    sludge_at = $7,
    input_value = $8,
    dominant_type = $9,
    updated_at = NOW()
WHERE user_id = $1
`

type UpdateCompostBinParams struct {
	UserID       uuid.UUID          `json:"user_id"`
	Status       string             `json:"status"`
	Items        []byte             `json:"items"`
	ItemCount    int32              `json:"item_count"`
	StartedAt    pgtype.Timestamptz `json:"started_at"`
	ReadyAt      pgtype.Timestamptz `json:"ready_at"`
	SludgeAt     pgtype.Timestamptz `json:"sludge_at"`
	InputValue   int32              `json:"input_value"`
	DominantType string             `json:"dominant_type"`
}

func (q *Queries) UpdateCompostBin(ctx context.Context, arg UpdateCompostBinParams) error {
	_, err := q.db.Exec(ctx, updateCompostBin,
		arg.UserID,
		arg.Status,
		arg.Items,
		arg.ItemCount,
		arg.StartedAt,
		arg.ReadyAt,
		arg.SludgeAt,
		arg.InputValue,
		arg.DominantType,
	)
	return err
}
