// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: item.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const assignItemTag = `-- name: AssignItemTag :exec
INSERT INTO item_type_assignments (item_id, item_type_id)
VALUES ($1, $2)
ON CONFLICT DO NOTHING
`

type AssignItemTagParams struct {
	ItemID     int32 `json:"item_id"`
	ItemTypeID int32 `json:"item_type_id"`
}

func (q *Queries) AssignItemTag(ctx context.Context, arg AssignItemTagParams) error {
	_, err := q.db.Exec(ctx, assignItemTag, arg.ItemID, arg.ItemTypeID)
	return err
}

const clearItemTags = `-- name: ClearItemTags :exec
DELETE FROM item_type_assignments WHERE item_id = $1
`

func (q *Queries) ClearItemTags(ctx context.Context, itemID int32) error {
	_, err := q.db.Exec(ctx, clearItemTags, itemID)
	return err
}

const getAllItemTypes = `-- name: GetAllItemTypes :many
SELECT item_type_id, type_name FROM item_types ORDER BY type_name
`

func (q *Queries) GetAllItemTypes(ctx context.Context) ([]ItemType, error) {
	rows, err := q.db.Query(ctx, getAllItemTypes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ItemType
	for rows.Next() {
		var i ItemType
		if err := rows.Scan(&i.ItemTypeID, &i.TypeName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemByInternalName = `-- name: GetItemByInternalName :one

SELECT
    i.item_id, i.internal_name, i.public_name, i.default_display, i.item_description, i.base_value, i.handler,
    i.content_type,
    COALESCE(array_agg(t.type_name) FILTER (WHERE t.type_name IS NOT NULL), '{}')::text[] as types
FROM items i
LEFT JOIN item_type_assignments ita ON i.item_id = ita.item_id
LEFT JOIN item_types t ON ita.item_type_id = t.item_type_id
WHERE i.internal_name = $1
GROUP BY i.item_id
`

type GetItemByInternalNameRow struct {
	ItemID          int32       `json:"item_id"`
	InternalName    string      `json:"internal_name"`
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
	Types           []string    `json:"types"`
}

// Item Repository Queries
func (q *Queries) GetItemByInternalName(ctx context.Context, internalName string) (GetItemByInternalNameRow, error) {
	row := q.db.QueryRow(ctx, getItemByInternalName, internalName)
	var i GetItemByInternalNameRow
	err := row.Scan(
		&i.ItemID,
		&i.InternalName,
		&i.PublicName,
		&i.DefaultDisplay,
		&i.ItemDescription,
		&i.BaseValue,
		&i.Handler,
		&i.ContentType,
		&i.Types,
	)
	return i, err
}

const getSyncMetadata = `-- name: GetSyncMetadata :one
SELECT config_name, last_sync_time, file_hash, file_mod_time
FROM config_sync_metadata
WHERE config_name = $1
`

type GetSyncMetadataRow struct {
	ConfigName   string             `json:"config_name"`
	LastSyncTime pgtype.Timestamptz `json:"last_sync_time"`
	FileHash     string             `json:"file_hash"`
	FileModTime  pgtype.Timestamptz `json:"file_mod_time"`
}

func (q *Queries) GetSyncMetadata(ctx context.Context, configName string) (GetSyncMetadataRow, error) {
	row := q.db.QueryRow(ctx, getSyncMetadata, configName)
	var i GetSyncMetadataRow
	err := row.Scan(
		&i.ConfigName,
		&i.LastSyncTime,
		&i.FileHash,
		&i.FileModTime,
	)
	return i, err
}

const insertItem = `-- name: InsertItem :one
INSERT INTO items (internal_name, public_name, default_display, item_description, base_value, handler, content_type)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING item_id
`

type InsertItemParams struct {
	InternalName    string      `json:"internal_name"`
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
}

func (q *Queries) InsertItem(ctx context.Context, arg InsertItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertItem,
		arg.InternalName,
		arg.PublicName,
		arg.DefaultDisplay,
		arg.ItemDescription,
		arg.BaseValue,
		arg.Handler,
		arg.ContentType,
	)
	var item_id int32
	err := row.Scan(&item_id)
	return item_id, err
}

const insertItemType = `-- name: InsertItemType :one
INSERT INTO item_types (type_name)
VALUES ($1)
ON CONFLICT (type_name) DO UPDATE SET type_name = EXCLUDED.type_name
RETURNING item_type_id
`

func (q *Queries) InsertItemType(ctx context.Context, typeName string) (int32, error) {
	row := q.db.QueryRow(ctx, insertItemType, typeName)
	var item_type_id int32
	err := row.Scan(&item_type_id)
	return item_type_id, err
}

const updateItem = `-- name: UpdateItem :exec
UPDATE items
SET public_name = $1, default_display = $2, item_description = $3, base_value = $4, handler = $5, content_type = $6
WHERE item_id = $7
`

type UpdateItemParams struct {
	PublicName      pgtype.Text `json:"public_name"`
	DefaultDisplay  pgtype.Text `json:"default_display"`
	ItemDescription pgtype.Text `json:"item_description"`
	BaseValue       pgtype.Int4 `json:"base_value"`
	Handler         pgtype.Text `json:"handler"`
	ContentType     []string    `json:"content_type"`
	ItemID          int32       `json:"item_id"`
}

func (q *Queries) UpdateItem(ctx context.Context, arg UpdateItemParams) error {
	_, err := q.db.Exec(ctx, updateItem,
		arg.PublicName,
		arg.DefaultDisplay,
		arg.ItemDescription,
		arg.BaseValue,
		arg.Handler,
		arg.ContentType,
		arg.ItemID,
	)
	return err
}

const upsertSyncMetadata = `-- name: UpsertSyncMetadata :exec
INSERT INTO config_sync_metadata (config_name, last_sync_time, file_hash, file_mod_time)
VALUES ($1, $2, $3, $4)
ON CONFLICT (config_name) DO UPDATE
SET last_sync_time = EXCLUDED.last_sync_time,
    file_hash = EXCLUDED.file_hash,
    file_mod_time = EXCLUDED.file_mod_time
`

type UpsertSyncMetadataParams struct {
	ConfigName   string             `json:"config_name"`
	LastSyncTime pgtype.Timestamptz `json:"last_sync_time"`
	FileHash     string             `json:"file_hash"`
	FileModTime  pgtype.Timestamptz `json:"file_mod_time"`
}

func (q *Queries) UpsertSyncMetadata(ctx context.Context, arg UpsertSyncMetadataParams) error {
	_, err := q.db.Exec(ctx, upsertSyncMetadata,
		arg.ConfigName,
		arg.LastSyncTime,
		arg.FileHash,
		arg.FileModTime,
	)
	return err
}
