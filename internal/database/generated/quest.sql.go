// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: quest.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const claimQuestReward = `-- name: ClaimQuestReward :exec
UPDATE quest_progress
SET claimed_at = NOW(), updated_at = NOW()
WHERE user_id = $1 AND quest_id = $2 AND claimed_at IS NULL
`

type ClaimQuestRewardParams struct {
	UserID  uuid.UUID `json:"user_id"`
	QuestID int32     `json:"quest_id"`
}

func (q *Queries) ClaimQuestReward(ctx context.Context, arg ClaimQuestRewardParams) error {
	_, err := q.db.Exec(ctx, claimQuestReward, arg.UserID, arg.QuestID)
	return err
}

const completeQuest = `-- name: CompleteQuest :exec
UPDATE quest_progress
SET completed_at = NOW(), updated_at = NOW()
WHERE user_id = $1 AND quest_id = $2 AND completed_at IS NULL
`

type CompleteQuestParams struct {
	UserID  uuid.UUID `json:"user_id"`
	QuestID int32     `json:"quest_id"`
}

func (q *Queries) CompleteQuest(ctx context.Context, arg CompleteQuestParams) error {
	_, err := q.db.Exec(ctx, completeQuest, arg.UserID, arg.QuestID)
	return err
}

const createQuest = `-- name: CreateQuest :one
INSERT INTO quests (
    quest_key, quest_type, description, target_category, target_recipe_key,
    base_requirement, base_reward_money, base_reward_xp,
    active, week_number, year
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING quest_id, quest_key, quest_type, description, target_category, target_recipe_key, base_requirement, base_reward_money, base_reward_xp, active, week_number, year, created_at, updated_at
`

type CreateQuestParams struct {
	QuestKey        string      `json:"quest_key"`
	QuestType       string      `json:"quest_type"`
	Description     string      `json:"description"`
	TargetCategory  pgtype.Text `json:"target_category"`
	TargetRecipeKey pgtype.Text `json:"target_recipe_key"`
	BaseRequirement int32       `json:"base_requirement"`
	BaseRewardMoney int32       `json:"base_reward_money"`
	BaseRewardXp    int32       `json:"base_reward_xp"`
	Active          bool        `json:"active"`
	WeekNumber      int32       `json:"week_number"`
	Year            int32       `json:"year"`
}

func (q *Queries) CreateQuest(ctx context.Context, arg CreateQuestParams) (Quest, error) {
	row := q.db.QueryRow(ctx, createQuest,
		arg.QuestKey,
		arg.QuestType,
		arg.Description,
		arg.TargetCategory,
		arg.TargetRecipeKey,
		arg.BaseRequirement,
		arg.BaseRewardMoney,
		arg.BaseRewardXp,
		arg.Active,
		arg.WeekNumber,
		arg.Year,
	)
	var i Quest
	err := row.Scan(
		&i.QuestID,
		&i.QuestKey,
		&i.QuestType,
		&i.Description,
		&i.TargetCategory,
		&i.TargetRecipeKey,
		&i.BaseRequirement,
		&i.BaseRewardMoney,
		&i.BaseRewardXp,
		&i.Active,
		&i.WeekNumber,
		&i.Year,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQuestProgress = `-- name: CreateQuestProgress :one
INSERT INTO quest_progress (
    user_id, quest_id, progress_current, progress_required,
    reward_money, reward_xp
) VALUES ($1, $2, $3, $4, $5, $6)
RETURNING user_id, quest_id, progress_current, progress_required, reward_money, reward_xp, started_at, completed_at, claimed_at, created_at, updated_at
`

type CreateQuestProgressParams struct {
	UserID           uuid.UUID `json:"user_id"`
	QuestID          int32     `json:"quest_id"`
	ProgressCurrent  int32     `json:"progress_current"`
	ProgressRequired int32     `json:"progress_required"`
	RewardMoney      int32     `json:"reward_money"`
	RewardXp         int32     `json:"reward_xp"`
}

func (q *Queries) CreateQuestProgress(ctx context.Context, arg CreateQuestProgressParams) (QuestProgress, error) {
	row := q.db.QueryRow(ctx, createQuestProgress,
		arg.UserID,
		arg.QuestID,
		arg.ProgressCurrent,
		arg.ProgressRequired,
		arg.RewardMoney,
		arg.RewardXp,
	)
	var i QuestProgress
	err := row.Scan(
		&i.UserID,
		&i.QuestID,
		&i.ProgressCurrent,
		&i.ProgressRequired,
		&i.RewardMoney,
		&i.RewardXp,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ClaimedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createQuestProgressForUser = `-- name: CreateQuestProgressForUser :one
INSERT INTO quest_progress (
    user_id, quest_id, progress_current, progress_required,
    reward_money, reward_xp
) VALUES ($1, $2, 0, $3, $4, $5)
ON CONFLICT (user_id, quest_id) DO NOTHING
RETURNING user_id, quest_id, progress_current, progress_required, reward_money, reward_xp, started_at, completed_at, claimed_at, created_at, updated_at
`

type CreateQuestProgressForUserParams struct {
	UserID           uuid.UUID `json:"user_id"`
	QuestID          int32     `json:"quest_id"`
	ProgressRequired int32     `json:"progress_required"`
	RewardMoney      int32     `json:"reward_money"`
	RewardXp         int32     `json:"reward_xp"`
}

func (q *Queries) CreateQuestProgressForUser(ctx context.Context, arg CreateQuestProgressForUserParams) (QuestProgress, error) {
	row := q.db.QueryRow(ctx, createQuestProgressForUser,
		arg.UserID,
		arg.QuestID,
		arg.ProgressRequired,
		arg.RewardMoney,
		arg.RewardXp,
	)
	var i QuestProgress
	err := row.Scan(
		&i.UserID,
		&i.QuestID,
		&i.ProgressCurrent,
		&i.ProgressRequired,
		&i.RewardMoney,
		&i.RewardXp,
		&i.StartedAt,
		&i.CompletedAt,
		&i.ClaimedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateAllQuests = `-- name: DeactivateAllQuests :exec
UPDATE quests SET active = FALSE WHERE active = TRUE
`

func (q *Queries) DeactivateAllQuests(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deactivateAllQuests)
	return err
}

const getActiveQuests = `-- name: GetActiveQuests :many
SELECT quest_id, quest_key, quest_type, description, target_category, target_recipe_key, base_requirement, base_reward_money, base_reward_xp, active, week_number, year, created_at, updated_at FROM quests
WHERE active = TRUE
ORDER BY quest_id
`

func (q *Queries) GetActiveQuests(ctx context.Context) ([]Quest, error) {
	rows, err := q.db.Query(ctx, getActiveQuests)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Quest
	for rows.Next() {
		var i Quest
		if err := rows.Scan(
			&i.QuestID,
			&i.QuestKey,
			&i.QuestType,
			&i.Description,
			&i.TargetCategory,
			&i.TargetRecipeKey,
			&i.BaseRequirement,
			&i.BaseRewardMoney,
			&i.BaseRewardXp,
			&i.Active,
			&i.WeekNumber,
			&i.Year,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getActiveQuestsForWeek = `-- name: GetActiveQuestsForWeek :many
SELECT quest_id, quest_key, quest_type, description, target_category, target_recipe_key, base_requirement, base_reward_money, base_reward_xp, active, week_number, year, created_at, updated_at FROM quests
WHERE active = TRUE AND year = $1 AND week_number = $2
ORDER BY quest_id
`

type GetActiveQuestsForWeekParams struct {
	Year       int32 `json:"year"`
	WeekNumber int32 `json:"week_number"`
}

func (q *Queries) GetActiveQuestsForWeek(ctx context.Context, arg GetActiveQuestsForWeekParams) ([]Quest, error) {
	rows, err := q.db.Query(ctx, getActiveQuestsForWeek, arg.Year, arg.WeekNumber)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Quest
	for rows.Next() {
		var i Quest
		if err := rows.Scan(
			&i.QuestID,
			&i.QuestKey,
			&i.QuestType,
			&i.Description,
			&i.TargetCategory,
			&i.TargetRecipeKey,
			&i.BaseRequirement,
			&i.BaseRewardMoney,
			&i.BaseRewardXp,
			&i.Active,
			&i.WeekNumber,
			&i.Year,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnclaimedCompletedQuests = `-- name: GetUnclaimedCompletedQuests :many
SELECT
    qp.user_id, qp.quest_id, qp.progress_current, qp.progress_required, qp.reward_money, qp.reward_xp, qp.started_at, qp.completed_at, qp.claimed_at, qp.created_at, qp.updated_at,
    q.quest_key,
    q.quest_type,
    q.description,
    q.target_category,
    q.target_recipe_key
FROM quest_progress qp
JOIN quests q ON qp.quest_id = q.quest_id
WHERE qp.user_id = $1
  AND qp.completed_at IS NOT NULL
  AND qp.claimed_at IS NULL
ORDER BY qp.completed_at ASC
`

type GetUnclaimedCompletedQuestsRow struct {
	UserID           uuid.UUID          `json:"user_id"`
	QuestID          int32              `json:"quest_id"`
	ProgressCurrent  int32              `json:"progress_current"`
	ProgressRequired int32              `json:"progress_required"`
	RewardMoney      int32              `json:"reward_money"`
	RewardXp         int32              `json:"reward_xp"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	ClaimedAt        pgtype.Timestamptz `json:"claimed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	QuestKey         string             `json:"quest_key"`
	QuestType        string             `json:"quest_type"`
	Description      string             `json:"description"`
	TargetCategory   pgtype.Text        `json:"target_category"`
	TargetRecipeKey  pgtype.Text        `json:"target_recipe_key"`
}

func (q *Queries) GetUnclaimedCompletedQuests(ctx context.Context, userID uuid.UUID) ([]GetUnclaimedCompletedQuestsRow, error) {
	rows, err := q.db.Query(ctx, getUnclaimedCompletedQuests, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUnclaimedCompletedQuestsRow
	for rows.Next() {
		var i GetUnclaimedCompletedQuestsRow
		if err := rows.Scan(
			&i.UserID,
			&i.QuestID,
			&i.ProgressCurrent,
			&i.ProgressRequired,
			&i.RewardMoney,
			&i.RewardXp,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ClaimedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuestKey,
			&i.QuestType,
			&i.Description,
			&i.TargetCategory,
			&i.TargetRecipeKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserActiveQuestProgress = `-- name: GetUserActiveQuestProgress :many
SELECT
    qp.user_id, qp.quest_id, qp.progress_current, qp.progress_required, qp.reward_money, qp.reward_xp, qp.started_at, qp.completed_at, qp.claimed_at, qp.created_at, qp.updated_at,
    q.quest_key,
    q.quest_type,
    q.description,
    q.target_category,
    q.target_recipe_key
FROM quest_progress qp
JOIN quests q ON qp.quest_id = q.quest_id
WHERE qp.user_id = $1 AND q.active = TRUE
ORDER BY qp.quest_id
`

type GetUserActiveQuestProgressRow struct {
	UserID           uuid.UUID          `json:"user_id"`
	QuestID          int32              `json:"quest_id"`
	ProgressCurrent  int32              `json:"progress_current"`
	ProgressRequired int32              `json:"progress_required"`
	RewardMoney      int32              `json:"reward_money"`
	RewardXp         int32              `json:"reward_xp"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	ClaimedAt        pgtype.Timestamptz `json:"claimed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	QuestKey         string             `json:"quest_key"`
	QuestType        string             `json:"quest_type"`
	Description      string             `json:"description"`
	TargetCategory   pgtype.Text        `json:"target_category"`
	TargetRecipeKey  pgtype.Text        `json:"target_recipe_key"`
}

func (q *Queries) GetUserActiveQuestProgress(ctx context.Context, userID uuid.UUID) ([]GetUserActiveQuestProgressRow, error) {
	rows, err := q.db.Query(ctx, getUserActiveQuestProgress, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserActiveQuestProgressRow
	for rows.Next() {
		var i GetUserActiveQuestProgressRow
		if err := rows.Scan(
			&i.UserID,
			&i.QuestID,
			&i.ProgressCurrent,
			&i.ProgressRequired,
			&i.RewardMoney,
			&i.RewardXp,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ClaimedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuestKey,
			&i.QuestType,
			&i.Description,
			&i.TargetCategory,
			&i.TargetRecipeKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserQuestProgress = `-- name: GetUserQuestProgress :many
SELECT
    qp.user_id, qp.quest_id, qp.progress_current, qp.progress_required, qp.reward_money, qp.reward_xp, qp.started_at, qp.completed_at, qp.claimed_at, qp.created_at, qp.updated_at,
    q.quest_key,
    q.quest_type,
    q.description,
    q.target_category,
    q.target_recipe_key
FROM quest_progress qp
JOIN quests q ON qp.quest_id = q.quest_id
WHERE qp.user_id = $1
ORDER BY qp.started_at DESC
`

type GetUserQuestProgressRow struct {
	UserID           uuid.UUID          `json:"user_id"`
	QuestID          int32              `json:"quest_id"`
	ProgressCurrent  int32              `json:"progress_current"`
	ProgressRequired int32              `json:"progress_required"`
	RewardMoney      int32              `json:"reward_money"`
	RewardXp         int32              `json:"reward_xp"`
	StartedAt        pgtype.Timestamptz `json:"started_at"`
	CompletedAt      pgtype.Timestamptz `json:"completed_at"`
	ClaimedAt        pgtype.Timestamptz `json:"claimed_at"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	QuestKey         string             `json:"quest_key"`
	QuestType        string             `json:"quest_type"`
	Description      string             `json:"description"`
	TargetCategory   pgtype.Text        `json:"target_category"`
	TargetRecipeKey  pgtype.Text        `json:"target_recipe_key"`
}

func (q *Queries) GetUserQuestProgress(ctx context.Context, userID uuid.UUID) ([]GetUserQuestProgressRow, error) {
	rows, err := q.db.Query(ctx, getUserQuestProgress, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserQuestProgressRow
	for rows.Next() {
		var i GetUserQuestProgressRow
		if err := rows.Scan(
			&i.UserID,
			&i.QuestID,
			&i.ProgressCurrent,
			&i.ProgressRequired,
			&i.RewardMoney,
			&i.RewardXp,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ClaimedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.QuestKey,
			&i.QuestType,
			&i.Description,
			&i.TargetCategory,
			&i.TargetRecipeKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getWeeklyQuestResetState = `-- name: GetWeeklyQuestResetState :one
SELECT id, last_reset_time, week_number, year, quests_generated, progress_reset FROM weekly_quest_reset_state WHERE id = 1
`

func (q *Queries) GetWeeklyQuestResetState(ctx context.Context) (WeeklyQuestResetState, error) {
	row := q.db.QueryRow(ctx, getWeeklyQuestResetState)
	var i WeeklyQuestResetState
	err := row.Scan(
		&i.ID,
		&i.LastResetTime,
		&i.WeekNumber,
		&i.Year,
		&i.QuestsGenerated,
		&i.ProgressReset,
	)
	return i, err
}

const incrementQuestProgress = `-- name: IncrementQuestProgress :exec
UPDATE quest_progress
SET progress_current = progress_current + $3, updated_at = NOW()
WHERE user_id = $1 AND quest_id = $2
`

type IncrementQuestProgressParams struct {
	UserID          uuid.UUID `json:"user_id"`
	QuestID         int32     `json:"quest_id"`
	ProgressCurrent int32     `json:"progress_current"`
}

func (q *Queries) IncrementQuestProgress(ctx context.Context, arg IncrementQuestProgressParams) error {
	_, err := q.db.Exec(ctx, incrementQuestProgress, arg.UserID, arg.QuestID, arg.ProgressCurrent)
	return err
}

const resetInactiveQuestProgress = `-- name: ResetInactiveQuestProgress :execresult
DELETE FROM quest_progress
WHERE quest_id IN (
    SELECT quest_id FROM quests WHERE active = FALSE
)
`

func (q *Queries) ResetInactiveQuestProgress(ctx context.Context) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, resetInactiveQuestProgress)
}

const updateWeeklyQuestResetState = `-- name: UpdateWeeklyQuestResetState :exec
UPDATE weekly_quest_reset_state
SET last_reset_time = $1, week_number = $2, year = $3,
    quests_generated = $4, progress_reset = $5
WHERE id = 1
`

type UpdateWeeklyQuestResetStateParams struct {
	LastResetTime   pgtype.Timestamptz `json:"last_reset_time"`
	WeekNumber      int32              `json:"week_number"`
	Year            int32              `json:"year"`
	QuestsGenerated int32              `json:"quests_generated"`
	ProgressReset   int32              `json:"progress_reset"`
}

func (q *Queries) UpdateWeeklyQuestResetState(ctx context.Context, arg UpdateWeeklyQuestResetStateParams) error {
	_, err := q.db.Exec(ctx, updateWeeklyQuestResetState,
		arg.LastResetTime,
		arg.WeekNumber,
		arg.Year,
		arg.QuestsGenerated,
		arg.ProgressReset,
	)
	return err
}
