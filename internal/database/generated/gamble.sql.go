// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: gamble.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const createGamble = `-- name: CreateGamble :exec
INSERT INTO gambles (id, initiator_id, state, created_at, join_deadline)
VALUES ($1, $2, $3, $4, $5)
`

type CreateGambleParams struct {
	ID           uuid.UUID          `json:"id"`
	InitiatorID  uuid.UUID          `json:"initiator_id"`
	State        string             `json:"state"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	JoinDeadline pgtype.Timestamptz `json:"join_deadline"`
}

func (q *Queries) CreateGamble(ctx context.Context, arg CreateGambleParams) error {
	_, err := q.db.Exec(ctx, createGamble,
		arg.ID,
		arg.InitiatorID,
		arg.State,
		arg.CreatedAt,
		arg.JoinDeadline,
	)
	return err
}

const getActiveGamble = `-- name: GetActiveGamble :one
SELECT id, initiator_id, state, created_at, join_deadline
FROM gambles
WHERE state IN ('Joining', 'Opening')
LIMIT 1
`

func (q *Queries) GetActiveGamble(ctx context.Context) (Gamble, error) {
	row := q.db.QueryRow(ctx, getActiveGamble)
	var i Gamble
	err := row.Scan(
		&i.ID,
		&i.InitiatorID,
		&i.State,
		&i.CreatedAt,
		&i.JoinDeadline,
	)
	return i, err
}

const getGamble = `-- name: GetGamble :one
SELECT id, initiator_id, state, created_at, join_deadline
FROM gambles
WHERE id = $1
`

func (q *Queries) GetGamble(ctx context.Context, id uuid.UUID) (Gamble, error) {
	row := q.db.QueryRow(ctx, getGamble, id)
	var i Gamble
	err := row.Scan(
		&i.ID,
		&i.InitiatorID,
		&i.State,
		&i.CreatedAt,
		&i.JoinDeadline,
	)
	return i, err
}

const getGambleParticipants = `-- name: GetGambleParticipants :many
SELECT p.gamble_id, p.user_id, p.lootbox_bets, u.username
FROM gamble_participants p
JOIN users u ON p.user_id = u.user_id
WHERE p.gamble_id = $1
`

type GetGambleParticipantsRow struct {
	GambleID    uuid.UUID `json:"gamble_id"`
	UserID      uuid.UUID `json:"user_id"`
	LootboxBets []byte    `json:"lootbox_bets"`
	Username    string    `json:"username"`
}

func (q *Queries) GetGambleParticipants(ctx context.Context, gambleID uuid.UUID) ([]GetGambleParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getGambleParticipants, gambleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGambleParticipantsRow
	for rows.Next() {
		var i GetGambleParticipantsRow
		if err := rows.Scan(
			&i.GambleID,
			&i.UserID,
			&i.LootboxBets,
			&i.Username,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const joinGamble = `-- name: JoinGamble :exec
INSERT INTO gamble_participants (gamble_id, user_id, lootbox_bets)
VALUES ($1, $2, $3)
`

type JoinGambleParams struct {
	GambleID    uuid.UUID `json:"gamble_id"`
	UserID      uuid.UUID `json:"user_id"`
	LootboxBets []byte    `json:"lootbox_bets"`
}

func (q *Queries) JoinGamble(ctx context.Context, arg JoinGambleParams) error {
	_, err := q.db.Exec(ctx, joinGamble, arg.GambleID, arg.UserID, arg.LootboxBets)
	return err
}

const saveOpenedItem = `-- name: SaveOpenedItem :exec
INSERT INTO gamble_opened_items (gamble_id, user_id, item_id, quantity, value)
VALUES ($1, $2, $3, $4, $5)
`

type SaveOpenedItemParams struct {
	GambleID pgtype.UUID `json:"gamble_id"`
	UserID   pgtype.UUID `json:"user_id"`
	ItemID   pgtype.Int4 `json:"item_id"`
	Quantity int32       `json:"quantity"`
	Value    int64       `json:"value"`
}

func (q *Queries) SaveOpenedItem(ctx context.Context, arg SaveOpenedItemParams) error {
	_, err := q.db.Exec(ctx, saveOpenedItem,
		arg.GambleID,
		arg.UserID,
		arg.ItemID,
		arg.Quantity,
		arg.Value,
	)
	return err
}

const updateGambleState = `-- name: UpdateGambleState :exec
UPDATE gambles 
SET state = $1 
WHERE id = $2
`

type UpdateGambleStateParams struct {
	State string    `json:"state"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) UpdateGambleState(ctx context.Context, arg UpdateGambleStateParams) error {
	_, err := q.db.Exec(ctx, updateGambleState, arg.State, arg.ID)
	return err
}

const updateGambleStateIfMatches = `-- name: UpdateGambleStateIfMatches :execresult
UPDATE gambles 
SET state = $1 
WHERE id = $2 AND state = $3
`

type UpdateGambleStateIfMatchesParams struct {
	State   string    `json:"state"`
	ID      uuid.UUID `json:"id"`
	State_2 string    `json:"state_2"`
}

func (q *Queries) UpdateGambleStateIfMatches(ctx context.Context, arg UpdateGambleStateIfMatchesParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateGambleStateIfMatches, arg.State, arg.ID, arg.State_2)
}
