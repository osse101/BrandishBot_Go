// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: expedition.sql

package generated

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgtype"
)

const addExpeditionParticipant = `-- name: AddExpeditionParticipant :exec
INSERT INTO expedition_participants (expedition_id, user_id, joined_at, username)
VALUES ($1, $2, $3, $4)
`

type AddExpeditionParticipantParams struct {
	ExpeditionID uuid.UUID          `json:"expedition_id"`
	UserID       uuid.UUID          `json:"user_id"`
	JoinedAt     pgtype.Timestamptz `json:"joined_at"`
	Username     pgtype.Text        `json:"username"`
}

func (q *Queries) AddExpeditionParticipant(ctx context.Context, arg AddExpeditionParticipantParams) error {
	_, err := q.db.Exec(ctx, addExpeditionParticipant,
		arg.ExpeditionID,
		arg.UserID,
		arg.JoinedAt,
		arg.Username,
	)
	return err
}

const completeExpedition = `-- name: CompleteExpedition :exec
UPDATE expeditions
SET state = 'Completed', completed_at = now()
WHERE id = $1
`

func (q *Queries) CompleteExpedition(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, completeExpedition, id)
	return err
}

const createExpedition = `-- name: CreateExpedition :exec
INSERT INTO expeditions (id, initiator_id, expedition_type, state, created_at, join_deadline, completion_deadline, metadata)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type CreateExpeditionParams struct {
	ID                 uuid.UUID          `json:"id"`
	InitiatorID        uuid.UUID          `json:"initiator_id"`
	ExpeditionType     string             `json:"expedition_type"`
	State              string             `json:"state"`
	CreatedAt          pgtype.Timestamptz `json:"created_at"`
	JoinDeadline       pgtype.Timestamptz `json:"join_deadline"`
	CompletionDeadline pgtype.Timestamptz `json:"completion_deadline"`
	Metadata           []byte             `json:"metadata"`
}

func (q *Queries) CreateExpedition(ctx context.Context, arg CreateExpeditionParams) error {
	_, err := q.db.Exec(ctx, createExpedition,
		arg.ID,
		arg.InitiatorID,
		arg.ExpeditionType,
		arg.State,
		arg.CreatedAt,
		arg.JoinDeadline,
		arg.CompletionDeadline,
		arg.Metadata,
	)
	return err
}

const getActiveExpedition = `-- name: GetActiveExpedition :one
SELECT id, initiator_id, expedition_type, state, created_at, join_deadline, completion_deadline, completed_at, metadata
FROM expeditions
WHERE state IN ('Recruiting', 'InProgress')
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetActiveExpedition(ctx context.Context) (Expedition, error) {
	row := q.db.QueryRow(ctx, getActiveExpedition)
	var i Expedition
	err := row.Scan(
		&i.ID,
		&i.InitiatorID,
		&i.ExpeditionType,
		&i.State,
		&i.CreatedAt,
		&i.JoinDeadline,
		&i.CompletionDeadline,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const getExpedition = `-- name: GetExpedition :one
SELECT id, initiator_id, expedition_type, state, created_at, join_deadline, completion_deadline, completed_at, metadata
FROM expeditions
WHERE id = $1
`

func (q *Queries) GetExpedition(ctx context.Context, id uuid.UUID) (Expedition, error) {
	row := q.db.QueryRow(ctx, getExpedition, id)
	var i Expedition
	err := row.Scan(
		&i.ID,
		&i.InitiatorID,
		&i.ExpeditionType,
		&i.State,
		&i.CreatedAt,
		&i.JoinDeadline,
		&i.CompletionDeadline,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const getExpeditionJournalEntries = `-- name: GetExpeditionJournalEntries :many
SELECT id, expedition_id, turn_number, encounter_type, outcome, skill_checked, skill_passed, primary_member, narrative, fatigue, purse, created_at
FROM expedition_journal_entries
WHERE expedition_id = $1
ORDER BY turn_number ASC
`

func (q *Queries) GetExpeditionJournalEntries(ctx context.Context, expeditionID uuid.UUID) ([]ExpeditionJournalEntry, error) {
	rows, err := q.db.Query(ctx, getExpeditionJournalEntries, expeditionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExpeditionJournalEntry
	for rows.Next() {
		var i ExpeditionJournalEntry
		if err := rows.Scan(
			&i.ID,
			&i.ExpeditionID,
			&i.TurnNumber,
			&i.EncounterType,
			&i.Outcome,
			&i.SkillChecked,
			&i.SkillPassed,
			&i.PrimaryMember,
			&i.Narrative,
			&i.Fatigue,
			&i.Purse,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpeditionParticipants = `-- name: GetExpeditionParticipants :many
SELECT ep.expedition_id, ep.user_id, ep.joined_at, ep.rewards, ep.username, ep.is_leader, ep.job_levels, ep.final_money, ep.final_xp, ep.final_items, u.username as u_username
FROM expedition_participants ep
JOIN users u ON ep.user_id = u.user_id
WHERE ep.expedition_id = $1
`

type GetExpeditionParticipantsRow struct {
	ExpeditionID uuid.UUID          `json:"expedition_id"`
	UserID       uuid.UUID          `json:"user_id"`
	JoinedAt     pgtype.Timestamptz `json:"joined_at"`
	Rewards      []byte             `json:"rewards"`
	Username     pgtype.Text        `json:"username"`
	IsLeader     pgtype.Bool        `json:"is_leader"`
	JobLevels    []byte             `json:"job_levels"`
	FinalMoney   pgtype.Int4        `json:"final_money"`
	FinalXp      pgtype.Int4        `json:"final_xp"`
	FinalItems   []byte             `json:"final_items"`
	UUsername    string             `json:"u_username"`
}

func (q *Queries) GetExpeditionParticipants(ctx context.Context, expeditionID uuid.UUID) ([]GetExpeditionParticipantsRow, error) {
	rows, err := q.db.Query(ctx, getExpeditionParticipants, expeditionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExpeditionParticipantsRow
	for rows.Next() {
		var i GetExpeditionParticipantsRow
		if err := rows.Scan(
			&i.ExpeditionID,
			&i.UserID,
			&i.JoinedAt,
			&i.Rewards,
			&i.Username,
			&i.IsLeader,
			&i.JobLevels,
			&i.FinalMoney,
			&i.FinalXp,
			&i.FinalItems,
			&i.UUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLastCompletedExpedition = `-- name: GetLastCompletedExpedition :one
SELECT id, initiator_id, expedition_type, state, created_at, join_deadline, completion_deadline, completed_at, metadata
FROM expeditions
WHERE state = 'Completed'
ORDER BY completed_at DESC
LIMIT 1
`

func (q *Queries) GetLastCompletedExpedition(ctx context.Context) (Expedition, error) {
	row := q.db.QueryRow(ctx, getLastCompletedExpedition)
	var i Expedition
	err := row.Scan(
		&i.ID,
		&i.InitiatorID,
		&i.ExpeditionType,
		&i.State,
		&i.CreatedAt,
		&i.JoinDeadline,
		&i.CompletionDeadline,
		&i.CompletedAt,
		&i.Metadata,
	)
	return i, err
}

const saveExpeditionJournalEntry = `-- name: SaveExpeditionJournalEntry :exec
INSERT INTO expedition_journal_entries (expedition_id, turn_number, encounter_type, outcome, skill_checked, skill_passed, primary_member, narrative, fatigue, purse)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type SaveExpeditionJournalEntryParams struct {
	ExpeditionID  uuid.UUID   `json:"expedition_id"`
	TurnNumber    int32       `json:"turn_number"`
	EncounterType string      `json:"encounter_type"`
	Outcome       string      `json:"outcome"`
	SkillChecked  pgtype.Text `json:"skill_checked"`
	SkillPassed   pgtype.Bool `json:"skill_passed"`
	PrimaryMember pgtype.Text `json:"primary_member"`
	Narrative     string      `json:"narrative"`
	Fatigue       int32       `json:"fatigue"`
	Purse         int32       `json:"purse"`
}

func (q *Queries) SaveExpeditionJournalEntry(ctx context.Context, arg SaveExpeditionJournalEntryParams) error {
	_, err := q.db.Exec(ctx, saveExpeditionJournalEntry,
		arg.ExpeditionID,
		arg.TurnNumber,
		arg.EncounterType,
		arg.Outcome,
		arg.SkillChecked,
		arg.SkillPassed,
		arg.PrimaryMember,
		arg.Narrative,
		arg.Fatigue,
		arg.Purse,
	)
	return err
}

const saveExpeditionParticipantRewards = `-- name: SaveExpeditionParticipantRewards :exec
UPDATE expedition_participants
SET rewards = $3
WHERE expedition_id = $1 AND user_id = $2
`

type SaveExpeditionParticipantRewardsParams struct {
	ExpeditionID uuid.UUID `json:"expedition_id"`
	UserID       uuid.UUID `json:"user_id"`
	Rewards      []byte    `json:"rewards"`
}

func (q *Queries) SaveExpeditionParticipantRewards(ctx context.Context, arg SaveExpeditionParticipantRewardsParams) error {
	_, err := q.db.Exec(ctx, saveExpeditionParticipantRewards, arg.ExpeditionID, arg.UserID, arg.Rewards)
	return err
}

const updateExpeditionParticipantResults = `-- name: UpdateExpeditionParticipantResults :exec
UPDATE expedition_participants
SET is_leader = $3, job_levels = $4, final_money = $5, final_xp = $6, final_items = $7
WHERE expedition_id = $1 AND user_id = $2
`

type UpdateExpeditionParticipantResultsParams struct {
	ExpeditionID uuid.UUID   `json:"expedition_id"`
	UserID       uuid.UUID   `json:"user_id"`
	IsLeader     pgtype.Bool `json:"is_leader"`
	JobLevels    []byte      `json:"job_levels"`
	FinalMoney   pgtype.Int4 `json:"final_money"`
	FinalXp      pgtype.Int4 `json:"final_xp"`
	FinalItems   []byte      `json:"final_items"`
}

func (q *Queries) UpdateExpeditionParticipantResults(ctx context.Context, arg UpdateExpeditionParticipantResultsParams) error {
	_, err := q.db.Exec(ctx, updateExpeditionParticipantResults,
		arg.ExpeditionID,
		arg.UserID,
		arg.IsLeader,
		arg.JobLevels,
		arg.FinalMoney,
		arg.FinalXp,
		arg.FinalItems,
	)
	return err
}

const updateExpeditionState = `-- name: UpdateExpeditionState :exec
UPDATE expeditions
SET state = $1
WHERE id = $2
`

type UpdateExpeditionStateParams struct {
	State string    `json:"state"`
	ID    uuid.UUID `json:"id"`
}

func (q *Queries) UpdateExpeditionState(ctx context.Context, arg UpdateExpeditionStateParams) error {
	_, err := q.db.Exec(ctx, updateExpeditionState, arg.State, arg.ID)
	return err
}

const updateExpeditionStateIfMatches = `-- name: UpdateExpeditionStateIfMatches :execresult
UPDATE expeditions
SET state = $1
WHERE id = $2 AND state = $3
`

type UpdateExpeditionStateIfMatchesParams struct {
	State   string    `json:"state"`
	ID      uuid.UUID `json:"id"`
	State_2 string    `json:"state_2"`
}

func (q *Queries) UpdateExpeditionStateIfMatches(ctx context.Context, arg UpdateExpeditionStateIfMatchesParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, updateExpeditionStateIfMatches, arg.State, arg.ID, arg.State_2)
}
