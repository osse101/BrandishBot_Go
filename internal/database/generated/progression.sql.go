// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: progression.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addContribution = `-- name: AddContribution :exec
UPDATE progression_unlock_progress
SET contributions_accumulated = contributions_accumulated + $2
WHERE id = $1
`

type AddContributionParams struct {
	ID                       int32 `json:"id"`
	ContributionsAccumulated int32 `json:"contributions_accumulated"`
}

func (q *Queries) AddContribution(ctx context.Context, arg AddContributionParams) error {
	_, err := q.db.Exec(ctx, addContribution, arg.ID, arg.ContributionsAccumulated)
	return err
}

const addVotingOption = `-- name: AddVotingOption :exec
INSERT INTO progression_voting_options (session_id, node_id, target_level, vote_count)
VALUES ($1, $2, $3, 0)
`

type AddVotingOptionParams struct {
	SessionID   int32 `json:"session_id"`
	NodeID      int32 `json:"node_id"`
	TargetLevel int32 `json:"target_level"`
}

func (q *Queries) AddVotingOption(ctx context.Context, arg AddVotingOptionParams) error {
	_, err := q.db.Exec(ctx, addVotingOption, arg.SessionID, arg.NodeID, arg.TargetLevel)
	return err
}

const clearAllUserProgression = `-- name: ClearAllUserProgression :exec
DELETE FROM user_progression
`

func (q *Queries) ClearAllUserProgression(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearAllUserProgression)
	return err
}

const clearAllUserVotes = `-- name: ClearAllUserVotes :exec
DELETE FROM user_votes
`

func (q *Queries) ClearAllUserVotes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearAllUserVotes)
	return err
}

const clearAllVoting = `-- name: ClearAllVoting :exec
DELETE FROM progression_voting
`

func (q *Queries) ClearAllVoting(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearAllVoting)
	return err
}

const clearUnlocksExceptRoot = `-- name: ClearUnlocksExceptRoot :exec
DELETE FROM progression_unlocks
WHERE node_id != (SELECT id FROM progression_nodes WHERE node_key = 'progression_system')
`

func (q *Queries) ClearUnlocksExceptRoot(ctx context.Context) error {
	_, err := q.db.Exec(ctx, clearUnlocksExceptRoot)
	return err
}

const completeUnlock = `-- name: CompleteUnlock :exec
UPDATE progression_unlock_progress
SET unlocked_at = NOW()
WHERE id = $1
`

func (q *Queries) CompleteUnlock(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, completeUnlock, id)
	return err
}

const countUnlocks = `-- name: CountUnlocks :one
SELECT COUNT(*) FROM progression_unlocks
`

func (q *Queries) CountUnlocks(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUnlocks)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUnlockProgress = `-- name: CreateUnlockProgress :one
INSERT INTO progression_unlock_progress (contributions_accumulated)
VALUES (0)
RETURNING id
`

func (q *Queries) CreateUnlockProgress(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, createUnlockProgress)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createVotingSession = `-- name: CreateVotingSession :one
INSERT INTO progression_voting_sessions (status)
VALUES ('voting')
RETURNING id
`

func (q *Queries) CreateVotingSession(ctx context.Context) (int32, error) {
	row := q.db.QueryRow(ctx, createVotingSession)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const endVoting = `-- name: EndVoting :exec
UPDATE progression_voting
SET is_active = false
WHERE node_id = $1 AND target_level = $2
`

type EndVotingParams struct {
	NodeID      pgtype.Int4 `json:"node_id"`
	TargetLevel pgtype.Int4 `json:"target_level"`
}

func (q *Queries) EndVoting(ctx context.Context, arg EndVotingParams) error {
	_, err := q.db.Exec(ctx, endVoting, arg.NodeID, arg.TargetLevel)
	return err
}

const endVotingSession = `-- name: EndVotingSession :exec
UPDATE progression_voting_sessions
SET ended_at = NOW(),
    winning_option_id = $2,
    status = 'completed'
WHERE id = $1
`

type EndVotingSessionParams struct {
	ID              int32       `json:"id"`
	WinningOptionID pgtype.Int4 `json:"winning_option_id"`
}

func (q *Queries) EndVotingSession(ctx context.Context, arg EndVotingSessionParams) error {
	_, err := q.db.Exec(ctx, endVotingSession, arg.ID, arg.WinningOptionID)
	return err
}

const getActiveSession = `-- name: GetActiveSession :one
SELECT id, started_at, ended_at, voting_deadline, winning_option_id, status
FROM progression_voting_sessions
WHERE status = ('voting')::text
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveSessionRow struct {
	ID              int32            `json:"id"`
	StartedAt       pgtype.Timestamp `json:"started_at"`
	EndedAt         pgtype.Timestamp `json:"ended_at"`
	VotingDeadline  pgtype.Timestamp `json:"voting_deadline"`
	WinningOptionID pgtype.Int4      `json:"winning_option_id"`
	Status          string           `json:"status"`
}

func (q *Queries) GetActiveSession(ctx context.Context) (GetActiveSessionRow, error) {
	row := q.db.QueryRow(ctx, getActiveSession)
	var i GetActiveSessionRow
	err := row.Scan(
		&i.ID,
		&i.StartedAt,
		&i.EndedAt,
		&i.VotingDeadline,
		&i.WinningOptionID,
		&i.Status,
	)
	return i, err
}

const getActiveUnlockProgress = `-- name: GetActiveUnlockProgress :one
SELECT id, node_id, target_level, contributions_accumulated, started_at, unlocked_at, voting_session_id
FROM progression_unlock_progress
WHERE unlocked_at IS NULL
ORDER BY started_at DESC
LIMIT 1
`

func (q *Queries) GetActiveUnlockProgress(ctx context.Context) (ProgressionUnlockProgress, error) {
	row := q.db.QueryRow(ctx, getActiveUnlockProgress)
	var i ProgressionUnlockProgress
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.TargetLevel,
		&i.ContributionsAccumulated,
		&i.StartedAt,
		&i.UnlockedAt,
		&i.VotingSessionID,
	)
	return i, err
}

const getActiveVoting = `-- name: GetActiveVoting :one
SELECT id, node_id, target_level, vote_count, voting_started_at, voting_ends_at, is_active
FROM progression_voting
WHERE is_active = true
ORDER BY voting_started_at DESC
LIMIT 1
`

func (q *Queries) GetActiveVoting(ctx context.Context) (ProgressionVoting, error) {
	row := q.db.QueryRow(ctx, getActiveVoting)
	var i ProgressionVoting
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.TargetLevel,
		&i.VoteCount,
		&i.VotingStartedAt,
		&i.VotingEndsAt,
		&i.IsActive,
	)
	return i, err
}

const getAllNodes = `-- name: GetAllNodes :many
SELECT id, node_key, node_type, display_name, description,
       max_level, unlock_cost, tier, size, category, sort_order, created_at
FROM progression_nodes
ORDER BY sort_order, id
`

type GetAllNodesRow struct {
	ID          int32            `json:"id"`
	NodeKey     string           `json:"node_key"`
	NodeType    string           `json:"node_type"`
	DisplayName string           `json:"display_name"`
	Description pgtype.Text      `json:"description"`
	MaxLevel    pgtype.Int4      `json:"max_level"`
	UnlockCost  pgtype.Int4      `json:"unlock_cost"`
	Tier        int32            `json:"tier"`
	Size        string           `json:"size"`
	Category    string           `json:"category"`
	SortOrder   pgtype.Int4      `json:"sort_order"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetAllNodes(ctx context.Context) ([]GetAllNodesRow, error) {
	rows, err := q.db.Query(ctx, getAllNodes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllNodesRow
	for rows.Next() {
		var i GetAllNodesRow
		if err := rows.Scan(
			&i.ID,
			&i.NodeKey,
			&i.NodeType,
			&i.DisplayName,
			&i.Description,
			&i.MaxLevel,
			&i.UnlockCost,
			&i.Tier,
			&i.Size,
			&i.Category,
			&i.SortOrder,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllUnlocks = `-- name: GetAllUnlocks :many
SELECT id, node_id, current_level, unlocked_at, unlocked_by, engagement_score
FROM progression_unlocks
ORDER BY unlocked_at
`

func (q *Queries) GetAllUnlocks(ctx context.Context) ([]ProgressionUnlock, error) {
	rows, err := q.db.Query(ctx, getAllUnlocks)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProgressionUnlock
	for rows.Next() {
		var i ProgressionUnlock
		if err := rows.Scan(
			&i.ID,
			&i.NodeID,
			&i.CurrentLevel,
			&i.UnlockedAt,
			&i.UnlockedBy,
			&i.EngagementScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEngagementMetricsAggregated = `-- name: GetEngagementMetricsAggregated :many
SELECT metric_type, SUM(metric_value)::bigint as total
FROM engagement_metrics
GROUP BY metric_type
`

type GetEngagementMetricsAggregatedRow struct {
	MetricType string `json:"metric_type"`
	Total      int64  `json:"total"`
}

func (q *Queries) GetEngagementMetricsAggregated(ctx context.Context) ([]GetEngagementMetricsAggregatedRow, error) {
	rows, err := q.db.Query(ctx, getEngagementMetricsAggregated)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEngagementMetricsAggregatedRow
	for rows.Next() {
		var i GetEngagementMetricsAggregatedRow
		if err := rows.Scan(&i.MetricType, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEngagementMetricsAggregatedSince = `-- name: GetEngagementMetricsAggregatedSince :many
SELECT metric_type, SUM(metric_value)::bigint as total
FROM engagement_metrics
WHERE recorded_at >= $1
GROUP BY metric_type
`

type GetEngagementMetricsAggregatedSinceRow struct {
	MetricType string `json:"metric_type"`
	Total      int64  `json:"total"`
}

func (q *Queries) GetEngagementMetricsAggregatedSince(ctx context.Context, recordedAt pgtype.Timestamp) ([]GetEngagementMetricsAggregatedSinceRow, error) {
	rows, err := q.db.Query(ctx, getEngagementMetricsAggregatedSince, recordedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEngagementMetricsAggregatedSinceRow
	for rows.Next() {
		var i GetEngagementMetricsAggregatedSinceRow
		if err := rows.Scan(&i.MetricType, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEngagementWeights = `-- name: GetEngagementWeights :many
SELECT metric_type, weight FROM engagement_weights
`

type GetEngagementWeightsRow struct {
	MetricType string         `json:"metric_type"`
	Weight     pgtype.Numeric `json:"weight"`
}

func (q *Queries) GetEngagementWeights(ctx context.Context) ([]GetEngagementWeightsRow, error) {
	rows, err := q.db.Query(ctx, getEngagementWeights)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEngagementWeightsRow
	for rows.Next() {
		var i GetEngagementWeightsRow
		if err := rows.Scan(&i.MetricType, &i.Weight); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodeByID = `-- name: GetNodeByID :one
SELECT id, node_key, node_type, display_name, description,
       max_level, unlock_cost, tier, size, category, sort_order, created_at
FROM progression_nodes
WHERE id = $1
`

type GetNodeByIDRow struct {
	ID          int32            `json:"id"`
	NodeKey     string           `json:"node_key"`
	NodeType    string           `json:"node_type"`
	DisplayName string           `json:"display_name"`
	Description pgtype.Text      `json:"description"`
	MaxLevel    pgtype.Int4      `json:"max_level"`
	UnlockCost  pgtype.Int4      `json:"unlock_cost"`
	Tier        int32            `json:"tier"`
	Size        string           `json:"size"`
	Category    string           `json:"category"`
	SortOrder   pgtype.Int4      `json:"sort_order"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetNodeByID(ctx context.Context, id int32) (GetNodeByIDRow, error) {
	row := q.db.QueryRow(ctx, getNodeByID, id)
	var i GetNodeByIDRow
	err := row.Scan(
		&i.ID,
		&i.NodeKey,
		&i.NodeType,
		&i.DisplayName,
		&i.Description,
		&i.MaxLevel,
		&i.UnlockCost,
		&i.Tier,
		&i.Size,
		&i.Category,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getNodeByKey = `-- name: GetNodeByKey :one
SELECT id, node_key, node_type, display_name, description,
       max_level, unlock_cost, tier, size, category, sort_order, created_at
FROM progression_nodes
WHERE node_key = $1
LIMIT 1
`

type GetNodeByKeyRow struct {
	ID          int32            `json:"id"`
	NodeKey     string           `json:"node_key"`
	NodeType    string           `json:"node_type"`
	DisplayName string           `json:"display_name"`
	Description pgtype.Text      `json:"description"`
	MaxLevel    pgtype.Int4      `json:"max_level"`
	UnlockCost  pgtype.Int4      `json:"unlock_cost"`
	Tier        int32            `json:"tier"`
	Size        string           `json:"size"`
	Category    string           `json:"category"`
	SortOrder   pgtype.Int4      `json:"sort_order"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetNodeByKey(ctx context.Context, nodeKey string) (GetNodeByKeyRow, error) {
	row := q.db.QueryRow(ctx, getNodeByKey, nodeKey)
	var i GetNodeByKeyRow
	err := row.Scan(
		&i.ID,
		&i.NodeKey,
		&i.NodeType,
		&i.DisplayName,
		&i.Description,
		&i.MaxLevel,
		&i.UnlockCost,
		&i.Tier,
		&i.Size,
		&i.Category,
		&i.SortOrder,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByID = `-- name: GetSessionByID :one
SELECT id, started_at, ended_at, voting_deadline, winning_option_id, status
FROM progression_voting_sessions
WHERE id = $1
`

type GetSessionByIDRow struct {
	ID              int32            `json:"id"`
	StartedAt       pgtype.Timestamp `json:"started_at"`
	EndedAt         pgtype.Timestamp `json:"ended_at"`
	VotingDeadline  pgtype.Timestamp `json:"voting_deadline"`
	WinningOptionID pgtype.Int4      `json:"winning_option_id"`
	Status          string           `json:"status"`
}

func (q *Queries) GetSessionByID(ctx context.Context, id int32) (GetSessionByIDRow, error) {
	row := q.db.QueryRow(ctx, getSessionByID, id)
	var i GetSessionByIDRow
	err := row.Scan(
		&i.ID,
		&i.StartedAt,
		&i.EndedAt,
		&i.VotingDeadline,
		&i.WinningOptionID,
		&i.Status,
	)
	return i, err
}

const getSessionOptions = `-- name: GetSessionOptions :many
SELECT o.id, o.session_id, o.node_id, o.target_level, o.vote_count, o.last_highest_vote_at
FROM progression_voting_options o
WHERE o.session_id = $1
ORDER BY o.id
`

type GetSessionOptionsRow struct {
	ID                int32            `json:"id"`
	SessionID         int32            `json:"session_id"`
	NodeID            int32            `json:"node_id"`
	TargetLevel       int32            `json:"target_level"`
	VoteCount         int32            `json:"vote_count"`
	LastHighestVoteAt pgtype.Timestamp `json:"last_highest_vote_at"`
}

func (q *Queries) GetSessionOptions(ctx context.Context, sessionID int32) ([]GetSessionOptionsRow, error) {
	rows, err := q.db.Query(ctx, getSessionOptions, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSessionOptionsRow
	for rows.Next() {
		var i GetSessionOptionsRow
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.NodeID,
			&i.TargetLevel,
			&i.VoteCount,
			&i.LastHighestVoteAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionVoters = `-- name: GetSessionVoters :many
SELECT DISTINCT user_id
FROM user_votes
WHERE session_id = $1
`

func (q *Queries) GetSessionVoters(ctx context.Context, sessionID pgtype.Int4) ([]string, error) {
	rows, err := q.db.Query(ctx, getSessionVoters, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_id string
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalEngagementScore = `-- name: GetTotalEngagementScore :one
SELECT COALESCE(SUM(metric_value), 0)::bigint FROM engagement_metrics
`

func (q *Queries) GetTotalEngagementScore(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalEngagementScore)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getUnlock = `-- name: GetUnlock :one
SELECT id, node_id, current_level, unlocked_at, unlocked_by, engagement_score
FROM progression_unlocks
WHERE node_id = $1 AND current_level = $2
`

type GetUnlockParams struct {
	NodeID       pgtype.Int4 `json:"node_id"`
	CurrentLevel pgtype.Int4 `json:"current_level"`
}

func (q *Queries) GetUnlock(ctx context.Context, arg GetUnlockParams) (ProgressionUnlock, error) {
	row := q.db.QueryRow(ctx, getUnlock, arg.NodeID, arg.CurrentLevel)
	var i ProgressionUnlock
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.CurrentLevel,
		&i.UnlockedAt,
		&i.UnlockedBy,
		&i.EngagementScore,
	)
	return i, err
}

const getUserEngagementAggregated = `-- name: GetUserEngagementAggregated :many
SELECT metric_type, SUM(metric_value)::bigint as total
FROM engagement_metrics
WHERE user_id = $1
GROUP BY metric_type
`

type GetUserEngagementAggregatedRow struct {
	MetricType string `json:"metric_type"`
	Total      int64  `json:"total"`
}

func (q *Queries) GetUserEngagementAggregated(ctx context.Context, userID string) ([]GetUserEngagementAggregatedRow, error) {
	rows, err := q.db.Query(ctx, getUserEngagementAggregated, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserEngagementAggregatedRow
	for rows.Next() {
		var i GetUserEngagementAggregatedRow
		if err := rows.Scan(&i.MetricType, &i.Total); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserProgressions = `-- name: GetUserProgressions :many
SELECT user_id, progression_type, progression_key, unlocked_at, metadata
FROM user_progression
WHERE user_id = $1 AND progression_type = $2
ORDER BY unlocked_at
`

type GetUserProgressionsParams struct {
	UserID          string `json:"user_id"`
	ProgressionType string `json:"progression_type"`
}

func (q *Queries) GetUserProgressions(ctx context.Context, arg GetUserProgressionsParams) ([]UserProgression, error) {
	rows, err := q.db.Query(ctx, getUserProgressions, arg.UserID, arg.ProgressionType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProgression
	for rows.Next() {
		var i UserProgression
		if err := rows.Scan(
			&i.UserID,
			&i.ProgressionType,
			&i.ProgressionKey,
			&i.UnlockedAt,
			&i.Metadata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVoting = `-- name: GetVoting :one
SELECT id, node_id, target_level, vote_count, voting_started_at, voting_ends_at, is_active
FROM progression_voting
WHERE node_id = $1 AND target_level = $2
`

type GetVotingParams struct {
	NodeID      pgtype.Int4 `json:"node_id"`
	TargetLevel pgtype.Int4 `json:"target_level"`
}

func (q *Queries) GetVoting(ctx context.Context, arg GetVotingParams) (ProgressionVoting, error) {
	row := q.db.QueryRow(ctx, getVoting, arg.NodeID, arg.TargetLevel)
	var i ProgressionVoting
	err := row.Scan(
		&i.ID,
		&i.NodeID,
		&i.TargetLevel,
		&i.VoteCount,
		&i.VotingStartedAt,
		&i.VotingEndsAt,
		&i.IsActive,
	)
	return i, err
}

const hasUserVoted = `-- name: HasUserVoted :one
SELECT EXISTS(
    SELECT 1 FROM user_votes
    WHERE user_id = $1 AND node_id = $2 AND target_level = $3
)
`

type HasUserVotedParams struct {
	UserID      string `json:"user_id"`
	NodeID      int32  `json:"node_id"`
	TargetLevel int32  `json:"target_level"`
}

func (q *Queries) HasUserVoted(ctx context.Context, arg HasUserVotedParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasUserVoted, arg.UserID, arg.NodeID, arg.TargetLevel)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const hasUserVotedInSession = `-- name: HasUserVotedInSession :one
SELECT EXISTS(
    SELECT 1 FROM user_votes
    WHERE user_id = $1 AND session_id = $2
)
`

type HasUserVotedInSessionParams struct {
	UserID    string      `json:"user_id"`
	SessionID pgtype.Int4 `json:"session_id"`
}

func (q *Queries) HasUserVotedInSession(ctx context.Context, arg HasUserVotedInSessionParams) (bool, error) {
	row := q.db.QueryRow(ctx, hasUserVotedInSession, arg.UserID, arg.SessionID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const incrementOptionVote = `-- name: IncrementOptionVote :exec
UPDATE progression_voting_options
SET vote_count = vote_count + 1
WHERE id = $1
`

func (q *Queries) IncrementOptionVote(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, incrementOptionVote, id)
	return err
}

const incrementVote = `-- name: IncrementVote :exec
UPDATE progression_voting
SET vote_count = vote_count + 1
WHERE node_id = $1 AND target_level = $2
`

type IncrementVoteParams struct {
	NodeID      pgtype.Int4 `json:"node_id"`
	TargetLevel pgtype.Int4 `json:"target_level"`
}

func (q *Queries) IncrementVote(ctx context.Context, arg IncrementVoteParams) error {
	_, err := q.db.Exec(ctx, incrementVote, arg.NodeID, arg.TargetLevel)
	return err
}

const insertNextUnlockProgress = `-- name: InsertNextUnlockProgress :one
INSERT INTO progression_unlock_progress (contributions_accumulated)
VALUES ($1)
RETURNING id
`

func (q *Queries) InsertNextUnlockProgress(ctx context.Context, contributionsAccumulated int32) (int32, error) {
	row := q.db.QueryRow(ctx, insertNextUnlockProgress, contributionsAccumulated)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertNode = `-- name: InsertNode :one
INSERT INTO progression_nodes (node_key, node_type, display_name, description, max_level, unlock_cost, tier, size, category, sort_order)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id
`

type InsertNodeParams struct {
	NodeKey     string      `json:"node_key"`
	NodeType    string      `json:"node_type"`
	DisplayName string      `json:"display_name"`
	Description pgtype.Text `json:"description"`
	MaxLevel    pgtype.Int4 `json:"max_level"`
	UnlockCost  pgtype.Int4 `json:"unlock_cost"`
	Tier        int32       `json:"tier"`
	Size        string      `json:"size"`
	Category    string      `json:"category"`
	SortOrder   pgtype.Int4 `json:"sort_order"`
}

func (q *Queries) InsertNode(ctx context.Context, arg InsertNodeParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertNode,
		arg.NodeKey,
		arg.NodeType,
		arg.DisplayName,
		arg.Description,
		arg.MaxLevel,
		arg.UnlockCost,
		arg.Tier,
		arg.Size,
		arg.Category,
		arg.SortOrder,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const isNodeUnlocked = `-- name: IsNodeUnlocked :one
SELECT EXISTS(
    SELECT 1 FROM progression_unlocks pu
    JOIN progression_nodes pn ON pu.node_id = pn.id
    WHERE pn.node_key = $1 AND pu.current_level >= $2
)
`

type IsNodeUnlockedParams struct {
	NodeKey      string      `json:"node_key"`
	CurrentLevel pgtype.Int4 `json:"current_level"`
}

func (q *Queries) IsNodeUnlocked(ctx context.Context, arg IsNodeUnlockedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isNodeUnlocked, arg.NodeKey, arg.CurrentLevel)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isUserProgressionUnlocked = `-- name: IsUserProgressionUnlocked :one
SELECT EXISTS(
    SELECT 1 FROM user_progression
    WHERE user_id = $1 AND progression_type = $2 AND progression_key = $3
)
`

type IsUserProgressionUnlockedParams struct {
	UserID          string `json:"user_id"`
	ProgressionType string `json:"progression_type"`
	ProgressionKey  string `json:"progression_key"`
}

func (q *Queries) IsUserProgressionUnlocked(ctx context.Context, arg IsUserProgressionUnlockedParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserProgressionUnlocked, arg.UserID, arg.ProgressionType, arg.ProgressionKey)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const recordEngagement = `-- name: RecordEngagement :exec
INSERT INTO engagement_metrics (user_id, metric_type, metric_value, metadata)
VALUES ($1, $2, $3, $4)
`

type RecordEngagementParams struct {
	UserID      string      `json:"user_id"`
	MetricType  string      `json:"metric_type"`
	MetricValue pgtype.Int4 `json:"metric_value"`
	Metadata    []byte      `json:"metadata"`
}

func (q *Queries) RecordEngagement(ctx context.Context, arg RecordEngagementParams) error {
	_, err := q.db.Exec(ctx, recordEngagement,
		arg.UserID,
		arg.MetricType,
		arg.MetricValue,
		arg.Metadata,
	)
	return err
}

const recordReset = `-- name: RecordReset :exec
INSERT INTO progression_resets (reset_by, reason, nodes_reset_count, engagement_score_at_reset)
VALUES ($1, $2, $3, $4)
`

type RecordResetParams struct {
	ResetBy                pgtype.Text `json:"reset_by"`
	Reason                 pgtype.Text `json:"reason"`
	NodesResetCount        pgtype.Int4 `json:"nodes_reset_count"`
	EngagementScoreAtReset pgtype.Int4 `json:"engagement_score_at_reset"`
}

func (q *Queries) RecordReset(ctx context.Context, arg RecordResetParams) error {
	_, err := q.db.Exec(ctx, recordReset,
		arg.ResetBy,
		arg.Reason,
		arg.NodesResetCount,
		arg.EngagementScoreAtReset,
	)
	return err
}

const recordUserSessionVote = `-- name: RecordUserSessionVote :exec
INSERT INTO user_votes (user_id, session_id, option_id, node_id, target_level)
VALUES ($1, $2, $3, $4, 1)
`

type RecordUserSessionVoteParams struct {
	UserID    string      `json:"user_id"`
	SessionID pgtype.Int4 `json:"session_id"`
	OptionID  pgtype.Int4 `json:"option_id"`
	NodeID    int32       `json:"node_id"`
}

func (q *Queries) RecordUserSessionVote(ctx context.Context, arg RecordUserSessionVoteParams) error {
	_, err := q.db.Exec(ctx, recordUserSessionVote,
		arg.UserID,
		arg.SessionID,
		arg.OptionID,
		arg.NodeID,
	)
	return err
}

const recordUserVote = `-- name: RecordUserVote :exec
INSERT INTO user_votes (user_id, node_id, target_level)
VALUES ($1, $2, $3)
ON CONFLICT (user_id, node_id, target_level) DO NOTHING
`

type RecordUserVoteParams struct {
	UserID      string `json:"user_id"`
	NodeID      int32  `json:"node_id"`
	TargetLevel int32  `json:"target_level"`
}

func (q *Queries) RecordUserVote(ctx context.Context, arg RecordUserVoteParams) error {
	_, err := q.db.Exec(ctx, recordUserVote, arg.UserID, arg.NodeID, arg.TargetLevel)
	return err
}

const relockNode = `-- name: RelockNode :exec
DELETE FROM progression_unlocks WHERE node_id = $1 AND current_level = $2
`

type RelockNodeParams struct {
	NodeID       pgtype.Int4 `json:"node_id"`
	CurrentLevel pgtype.Int4 `json:"current_level"`
}

func (q *Queries) RelockNode(ctx context.Context, arg RelockNodeParams) error {
	_, err := q.db.Exec(ctx, relockNode, arg.NodeID, arg.CurrentLevel)
	return err
}

const setUnlockTarget = `-- name: SetUnlockTarget :exec
UPDATE progression_unlock_progress
SET node_id = $2, target_level = $3, voting_session_id = $4
WHERE id = $1
`

type SetUnlockTargetParams struct {
	ID              int32       `json:"id"`
	NodeID          pgtype.Int4 `json:"node_id"`
	TargetLevel     pgtype.Int4 `json:"target_level"`
	VotingSessionID pgtype.Int4 `json:"voting_session_id"`
}

func (q *Queries) SetUnlockTarget(ctx context.Context, arg SetUnlockTargetParams) error {
	_, err := q.db.Exec(ctx, setUnlockTarget,
		arg.ID,
		arg.NodeID,
		arg.TargetLevel,
		arg.VotingSessionID,
	)
	return err
}

const startVoting = `-- name: StartVoting :exec
INSERT INTO progression_voting (node_id, target_level, vote_count, voting_ends_at, is_active)
VALUES ($1, $2, 0, $3, true)
ON CONFLICT (node_id, target_level) DO UPDATE
SET voting_started_at = CURRENT_TIMESTAMP, voting_ends_at = $3, is_active = true, vote_count = 0
`

type StartVotingParams struct {
	NodeID       pgtype.Int4      `json:"node_id"`
	TargetLevel  pgtype.Int4      `json:"target_level"`
	VotingEndsAt pgtype.Timestamp `json:"voting_ends_at"`
}

func (q *Queries) StartVoting(ctx context.Context, arg StartVotingParams) error {
	_, err := q.db.Exec(ctx, startVoting, arg.NodeID, arg.TargetLevel, arg.VotingEndsAt)
	return err
}

const unlockNode = `-- name: UnlockNode :exec
INSERT INTO progression_unlocks (node_id, current_level, unlocked_by, engagement_score)
VALUES ($1, $2, $3, $4)
ON CONFLICT (node_id, current_level) DO NOTHING
`

type UnlockNodeParams struct {
	NodeID          pgtype.Int4 `json:"node_id"`
	CurrentLevel    pgtype.Int4 `json:"current_level"`
	UnlockedBy      pgtype.Text `json:"unlocked_by"`
	EngagementScore pgtype.Int4 `json:"engagement_score"`
}

func (q *Queries) UnlockNode(ctx context.Context, arg UnlockNodeParams) error {
	_, err := q.db.Exec(ctx, unlockNode,
		arg.NodeID,
		arg.CurrentLevel,
		arg.UnlockedBy,
		arg.EngagementScore,
	)
	return err
}

const unlockUserProgression = `-- name: UnlockUserProgression :exec
INSERT INTO user_progression (user_id, progression_type, progression_key, metadata)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, progression_type, progression_key) DO NOTHING
`

type UnlockUserProgressionParams struct {
	UserID          string `json:"user_id"`
	ProgressionType string `json:"progression_type"`
	ProgressionKey  string `json:"progression_key"`
	Metadata        []byte `json:"metadata"`
}

func (q *Queries) UnlockUserProgression(ctx context.Context, arg UnlockUserProgressionParams) error {
	_, err := q.db.Exec(ctx, unlockUserProgression,
		arg.UserID,
		arg.ProgressionType,
		arg.ProgressionKey,
		arg.Metadata,
	)
	return err
}

const updateNode = `-- name: UpdateNode :exec
UPDATE progression_nodes 
SET node_type = $2, display_name = $3, description = $4,
    max_level = $5, unlock_cost = $6, tier = $7, size = $8, category = $9, sort_order = $10
WHERE id = $1
`

type UpdateNodeParams struct {
	ID          int32       `json:"id"`
	NodeType    string      `json:"node_type"`
	DisplayName string      `json:"display_name"`
	Description pgtype.Text `json:"description"`
	MaxLevel    pgtype.Int4 `json:"max_level"`
	UnlockCost  pgtype.Int4 `json:"unlock_cost"`
	Tier        int32       `json:"tier"`
	Size        string      `json:"size"`
	Category    string      `json:"category"`
	SortOrder   pgtype.Int4 `json:"sort_order"`
}

func (q *Queries) UpdateNode(ctx context.Context, arg UpdateNodeParams) error {
	_, err := q.db.Exec(ctx, updateNode,
		arg.ID,
		arg.NodeType,
		arg.DisplayName,
		arg.Description,
		arg.MaxLevel,
		arg.UnlockCost,
		arg.Tier,
		arg.Size,
		arg.Category,
		arg.SortOrder,
	)
	return err
}

const updateOptionLastHighest = `-- name: UpdateOptionLastHighest :exec
UPDATE progression_voting_options o
SET last_highest_vote_at = NOW()
WHERE o.id = $1
  AND o.vote_count = (
      SELECT MAX(vote_count) FROM progression_voting_options
      WHERE session_id = o.session_id
  )
  AND (o.last_highest_vote_at IS NULL OR EXISTS (
      SELECT 1 FROM progression_voting_options o2
      WHERE o2.session_id = o.session_id
        AND o2.id != o.id
        AND o2.vote_count = o.vote_count
  ))
`

func (q *Queries) UpdateOptionLastHighest(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, updateOptionLastHighest, id)
	return err
}
