// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: stats.sql

package generated

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEventCounts = `-- name: GetEventCounts :many
SELECT event_type, COUNT(*) as count
FROM stats_events
WHERE created_at >= $1 AND created_at <= $2
GROUP BY event_type
`

type GetEventCountsParams struct {
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
}

type GetEventCountsRow struct {
	EventType string `json:"event_type"`
	Count     int64  `json:"count"`
}

func (q *Queries) GetEventCounts(ctx context.Context, arg GetEventCountsParams) ([]GetEventCountsRow, error) {
	rows, err := q.db.Query(ctx, getEventCounts, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEventCountsRow
	for rows.Next() {
		var i GetEventCountsRow
		if err := rows.Scan(&i.EventType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByType = `-- name: GetEventsByType :many
SELECT event_id, user_id, event_type, event_data, created_at
FROM stats_events
WHERE event_type = $1 AND created_at >= $2 AND created_at <= $3
ORDER BY created_at DESC
`

type GetEventsByTypeParams struct {
	EventType   string           `json:"event_type"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
}

func (q *Queries) GetEventsByType(ctx context.Context, arg GetEventsByTypeParams) ([]StatsEvent, error) {
	rows, err := q.db.Query(ctx, getEventsByType, arg.EventType, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsEvent
	for rows.Next() {
		var i StatsEvent
		if err := rows.Scan(
			&i.EventID,
			&i.UserID,
			&i.EventType,
			&i.EventData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventsByUser = `-- name: GetEventsByUser :many
SELECT event_id, user_id, event_type, event_data, created_at
FROM stats_events
WHERE user_id = $1 AND created_at >= $2 AND created_at <= $3
ORDER BY created_at DESC
`

type GetEventsByUserParams struct {
	UserID      pgtype.UUID      `json:"user_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
}

func (q *Queries) GetEventsByUser(ctx context.Context, arg GetEventsByUserParams) ([]StatsEvent, error) {
	rows, err := q.db.Query(ctx, getEventsByUser, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsEvent
	for rows.Next() {
		var i StatsEvent
		if err := rows.Scan(
			&i.EventID,
			&i.UserID,
			&i.EventType,
			&i.EventData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUsers = `-- name: GetTopUsers :many
SELECT se.user_id, u.username, COUNT(*) as event_count
FROM stats_events se
JOIN users u ON se.user_id = u.user_id
WHERE se.event_type = $1 AND se.created_at >= $2 AND se.created_at <= $3
GROUP BY se.user_id, u.username
ORDER BY event_count DESC
LIMIT $4
`

type GetTopUsersParams struct {
	EventType   string           `json:"event_type"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
	Limit       int32            `json:"limit"`
}

type GetTopUsersRow struct {
	UserID     pgtype.UUID `json:"user_id"`
	Username   string      `json:"username"`
	EventCount int64       `json:"event_count"`
}

func (q *Queries) GetTopUsers(ctx context.Context, arg GetTopUsersParams) ([]GetTopUsersRow, error) {
	rows, err := q.db.Query(ctx, getTopUsers,
		arg.EventType,
		arg.CreatedAt,
		arg.CreatedAt_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTopUsersRow
	for rows.Next() {
		var i GetTopUsersRow
		if err := rows.Scan(&i.UserID, &i.Username, &i.EventCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTotalEventCount = `-- name: GetTotalEventCount :one
SELECT COUNT(*)
FROM stats_events
WHERE created_at >= $1 AND created_at <= $2
`

type GetTotalEventCountParams struct {
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
}

func (q *Queries) GetTotalEventCount(ctx context.Context, arg GetTotalEventCountParams) (int64, error) {
	row := q.db.QueryRow(ctx, getTotalEventCount, arg.CreatedAt, arg.CreatedAt_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserEventCounts = `-- name: GetUserEventCounts :many
SELECT event_type, COUNT(*) as count
FROM stats_events
WHERE user_id = $1 AND created_at >= $2 AND created_at <= $3
GROUP BY event_type
`

type GetUserEventCountsParams struct {
	UserID      pgtype.UUID      `json:"user_id"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	CreatedAt_2 pgtype.Timestamp `json:"created_at_2"`
}

type GetUserEventCountsRow struct {
	EventType string `json:"event_type"`
	Count     int64  `json:"count"`
}

func (q *Queries) GetUserEventCounts(ctx context.Context, arg GetUserEventCountsParams) ([]GetUserEventCountsRow, error) {
	rows, err := q.db.Query(ctx, getUserEventCounts, arg.UserID, arg.CreatedAt, arg.CreatedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserEventCountsRow
	for rows.Next() {
		var i GetUserEventCountsRow
		if err := rows.Scan(&i.EventType, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEventsByType = `-- name: GetUserEventsByType :many
SELECT event_id, user_id, event_type, event_data, created_at
FROM stats_events
WHERE user_id = $1 AND event_type = $2
ORDER BY created_at DESC
LIMIT $3
`

type GetUserEventsByTypeParams struct {
	UserID    pgtype.UUID `json:"user_id"`
	EventType string      `json:"event_type"`
	Limit     int32       `json:"limit"`
}

func (q *Queries) GetUserEventsByType(ctx context.Context, arg GetUserEventsByTypeParams) ([]StatsEvent, error) {
	rows, err := q.db.Query(ctx, getUserEventsByType, arg.UserID, arg.EventType, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []StatsEvent
	for rows.Next() {
		var i StatsEvent
		if err := rows.Scan(
			&i.EventID,
			&i.UserID,
			&i.EventType,
			&i.EventData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const recordEvent = `-- name: RecordEvent :one
INSERT INTO stats_events (user_id, event_type, event_data, created_at)
VALUES ($1, $2, $3, $4)
RETURNING event_id, created_at
`

type RecordEventParams struct {
	UserID    pgtype.UUID      `json:"user_id"`
	EventType string           `json:"event_type"`
	EventData []byte           `json:"event_data"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

type RecordEventRow struct {
	EventID   int64            `json:"event_id"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) RecordEvent(ctx context.Context, arg RecordEventParams) (RecordEventRow, error) {
	row := q.db.QueryRow(ctx, recordEvent,
		arg.UserID,
		arg.EventType,
		arg.EventData,
		arg.CreatedAt,
	)
	var i RecordEventRow
	err := row.Scan(&i.EventID, &i.CreatedAt)
	return i, err
}
